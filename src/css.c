
#include "css.h"
#include "cssInt.h"

#include <stdlib.h>

#include <tcl.h>
#include <string.h>
#include <assert.h>

#include <stdio.h>
#include <errno.h>

#define TRACE_PARSER_CALLS 0
#define TRACE_STYLE_APPLICATION 0
#define TRACE_PROPERTY_PARSE 0

#define MAX(x,y) ((x)>(y)?(x):(y))
#define MIN(x,y) ((x)<(y)?(x):(y))

/* Declarations for the parser functions generated by lemon. These are used
 * by HtmlCssParse() and HtmlCssParseStyle().
 */
void *tkhtmlCssParserAlloc(void *(*)(size_t));
void tkhtmlCssParser(void *, int, CssToken, CssParse*);
void tkhtmlCssParserFree(void *, void (*)(void *));

static void propertiesAdd(CssProperties **, CssRule *);
static int cssGetToken(CONST char *, int , int *);

/*
 *---------------------------------------------------------------------------
 *
 * constantToString --
 *
 *     Transform an integer constant to it's string representation (for
 *     debugging). All of the constants that start with CSS_* are
 *     supported.
 *
 * Results:
 *     Pointer to a static string.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static const char *constantToString(int c){
    switch( c ){
        case CSS_SELECTORCHAIN_DESCENDANT: 
            return "CSS_SELECTORCHAIN_DESCENDANT";
        case CSS_SELECTORCHAIN_CHILD: 
            return "CSS_SELECTORCHAIN_CHILD";
        case CSS_SELECTORCHAIN_ADJACENT: 
            return "CSS_SELECTORCHAIN_ADJACENT";
        case CSS_SELECTOR_UNIVERSAL: 
            return "CSS_SELECTOR_UNIVERSAL";
        case CSS_SELECTOR_TYPE: 
            return "CSS_SELECTOR_TYPE";
        case CSS_SELECTOR_ATTR: 
            return "CSS_SELECTOR_ATTR";
        case CSS_SELECTOR_ATTRVALUE: 
            return "CSS_SELECTOR_ATTRVALUE";
        case CSS_SELECTOR_ATTRLISTVALUE: 
            return "CSS_SELECTOR_ATTRLISTVALUE";
        case CSS_SELECTOR_ATTRHYPHEN: 
            return "CSS_SELECTOR_ATTRHYPHEN";
        case CSS_PSEUDOCLASS_LANG: 
            return "CSS_PSEUDOCLASS_LANG";
        case CSS_PSEUDOCLASS_FIRSTCHILD: 
            return "CSS_PSEUDOCLASS_FIRSTCHILD";
        case CSS_PSEUDOCLASS_LINK:  
            return "CSS_PSEUDOCLASS_LINK";
        case CSS_PSEUDOCLASS_VISITED: 
            return "CSS_PSEUDOCLASS_VISITED";
        case CSS_PSEUDOCLASS_ACTIVE:  
            return "CSS_PSEUDOCLASS_ACTIVE";
        case CSS_PSEUDOCLASS_HOVER: 
            return "CSS_PSEUDOCLASS_HOVER";
        case CSS_PSEUDOCLASS_FOCUS: 
            return "CSS_PSEUDOCLASS_FOCUS";
        case CSS_PSEUDOELEMENT_FIRSTLINE: 
            return "CSS_PSEUDOELEMENT_FIRSTLINE";
        case CSS_PSEUDOELEMENT_FIRSTLETTER: 
            return "CSS_PSEUDOELEMENT_FIRSTLETTER";
        case CSS_PSEUDOELEMENT_BEFORE: 
            return "CSS_PSEUDOELEMENT_BEFORE";
        case CSS_PSEUDOELEMENT_AFTER: 
            return "CSS_PSEUDOELEMENT_AFTER";
        case CSS_MEDIA_ALL: 
            return "CSS_MEDIA_ALL";
        case CSS_MEDIA_AURAL: 
            return "CSS_MEDIA_AURAL";
        case CSS_MEDIA_BRAILLE: 
            return "CSS_MEDIA_BRAILLE";
        case CSS_MEDIA_EMBOSSED: 
            return "CSS_MEDIA_EMBOSSED";
        case CSS_MEDIA_HANDHELD: 
            return "CSS_MEDIA_HANDHELD";
        case CSS_MEDIA_PRINT: 
            return "CSS_MEDIA_PRINT";
        case CSS_MEDIA_PROJECTION: 
            return "CSS_MEDIA_PROJECTION";
        case CSS_MEDIA_SCREEN: 
            return "CSS_MEDIA_SCREEN";
        case CSS_MEDIA_TTY: 
            return "CSS_MEDIA_TTY";
        case CSS_MEDIA_TV: 
            return "CSS_MEDIA_TV";
    }
    return "unknown";
}

/*--------------------------------------------------------------------------
 *
 * tokenToString --
 *
 *     This function returns a null-terminated string (allocated by ckalloc)
 *     populated with the contents of the supplied token.
 *
 * Results:
 *     Null-terminated string. Caller is responsible for calling ckfree()
 *     on it.
 *
 * Side effects:
 *     None.
 *
 *--------------------------------------------------------------------------
 */
static char *tokenToString(CssToken *pToken){
    char *zRet;
    if( !pToken || pToken->n<=0 ){
         return 0;
    }
    zRet = (char *)ckalloc(pToken->n+1);
    memcpy(zRet, pToken->z, pToken->n);
    zRet[pToken->n] = '\0';
    return zRet;
}

/*
 *---------------------------------------------------------------------------
 *
 * tokenToReal --
 *
 *     Try to convert the token pToken to a floating point number. The
 *     conversion is considered successful if pToken starts with anything
 *     that looks like a floating point number. "0.0px" and "0px" convert
 *     successfully, "px" does not. Return non-zero if the conversion is
 *     succcesful, else zero.
 *
 *     Write the floating point number to *pVal. Write the number of bytes
 *     convereted to *pLen.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static int tokenToReal(pToken, pLen, pVal)
    CssToken *pToken;
    int *pLen;
    double *pVal;
{
    char zBuf[100];
    char *zEnd;
    if (pToken->n>99) {
        return 0;
    }
    strncpy(zBuf, pToken->z, pToken->n);
    zBuf[pToken->n] = '\0';
    *pVal = strtod(zBuf, &zEnd);
    if (zEnd!=zBuf) {
        *pLen = (zEnd-zBuf);
        return 1;
    }
    return 0;
}

/*
 *---------------------------------------------------------------------------
 *
 * rgbToColor --
 *
 *     This function is invoked when a property value of the form 
 *     "rgb(rrr, ggg, bbb)" is encountered. This routine interprets the
 *     property and transforms it to a string of the form #AAAAAA which can
 *     be understood as a color by Tk.
 *
 *     The first argument, zOut, points to a buffer of not less than 8
 *     bytes. The output string and it's NULL terminator is written here.
 *     The second parameter, zRgb, points to the first byte past the '('
 *     character of the original property value. The final parameter, nRgb,
 *     is the number of bytes between the '(' and ')' character of the
 *     original property.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     Writes exactly 8 bytes to zOut.
 *
 *---------------------------------------------------------------------------
 */
static void 
rgbToColor(zOut, zRgb, nRgb)
    char *zOut;
    CONST char *zRgb;
    int nRgb;
{
    CONST char *z = zRgb;
    CONST char *zEnd = zRgb+nRgb;
    int n = 0;
    int aN[3] = {0, 0, 0};

    while (z < zEnd && n < 3) {
        while (!isdigit(*z)) z++;
        aN[n] = strtol(z, (char **)&z, 0);
        if (*z=='%') {
            aN[n] = ((aN[n] * 100) / 255);
        }
        n++;
    }

    sprintf(zOut, "#%.2x%.2x%.2x", aN[0], aN[1], aN[2]);
}

/*
 *---------------------------------------------------------------------------
 *
 * tokenToProperty --
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static CssProperty *
tokenToProperty(pToken)
    CssToken *pToken;
{
    struct LengthFormat {
        int type;
        int len;
        char *zUnit;
        int integer;
    } lengths[] = {
        {CSS_TYPE_EM,         2, "em", 0},
        {CSS_TYPE_EX,         2, "ex", 0},
        {CSS_TYPE_PX,         2, "px", 1},
        {CSS_TYPE_PT,         2, "pt", 1},
        {CSS_TYPE_PERCENT,    1, "%", 1},
        {CSS_TYPE_FLOAT,      0, "", 0},
        {CSS_TYPE_CENTIMETER, 2, "cm", 0},
        {CSS_TYPE_MILLIMETER, 2, "mm", 0},
        {CSS_TYPE_INCH,       2, "in", 0},
        {CSS_TYPE_PC,         2, "pc", 0},
    };

    struct FunctionFormat {
        int type;
        int len;
        char *zFunc;
    } functions[] = {
        {CSS_TYPE_TCL, 3, "tcl"},
        {CSS_TYPE_URL, 3, "url"},
        {-1,           3, "rgb"},
    };

    struct KeywordFormat {
        int type;
        CONST char *zKeyword;
    } keywords[] = {
        {CSS_TYPE_INHERIT, "inherit"},
    };

    CssProperty *pProp = 0;
    int i;
    double realval;       /* Real value, if token can be converted to float */
    int reallen;          /* Bytes of token converted to realval */

    CONST char *z = pToken->z;
    int n = pToken->n;

    /* Check if this is a length. It is a length if the token consists
     * of a floating point number followed by one of the units enumerated
     * above in the array of LengthFormat structs.
     */
    if (tokenToReal(pToken, &reallen, &realval)) {
        for (i=0; i<(sizeof(lengths)/sizeof(lengths[0])); i++) {
            CONST char *zTokenUnit = &z[reallen];
            if ((n-reallen)==lengths[i].len &&
                    0==strncmp(zTokenUnit, lengths[i].zUnit, lengths[i].len)) {
                pProp = (CssProperty *)ckalloc(sizeof(CssProperty));
                pProp->eType = lengths[i].type;
                if (lengths[i].integer) {
                    pProp->v.iVal = (int)realval;
                } else {
                    pProp->v.rVal = realval;
                }
                break;
            }
        }
    }

    /* Check if this is a function call. A function call is anything that
     * begins with one or more alphabetic characters and a '(' character.
     * The last character of the token must be ')'.
     */
    if (z[n-1]==')') {
        for (i=0; i<n && isalpha((int)z[i]); i++);
        if (i<n && i>0 && z[i]=='(') {
            int l = i;
            int nFunc = sizeof(functions)/sizeof(struct FunctionFormat);
            for (i=0; pProp==0 && i<nFunc; i++) {
                if (l==functions[i].len && 0==strncmp(functions[i].zFunc,z,l)) {
                    char CONST *zArg;
                    int nArg;

                    zArg = &z[l+1];
                    nArg = (n-l-2); /* len(token)-len(func)-len('(')-len(')') */

                    if (functions[i].type==-1) {
                        /* -1 means this is an RGB value. Transform to a
                         * color string that Tcl can understand before
			 * storing it in the properties database. The color
			 * string will be 7 characters long exactly.
                         */
                        int nAlloc = sizeof(CssProperty) + 7 + 1;
                        pProp = (CssProperty *)ckalloc(nAlloc);
                        pProp->eType = CSS_TYPE_STRING;
                        pProp->v.zVal = (char *)&pProp[1];
                        rgbToColor(pProp->v.zVal, zArg, nArg);
                    } else {
                        int nAlloc = sizeof(CssProperty) + nArg + 1;
                        pProp = (CssProperty *)ckalloc(nAlloc);
                        pProp->eType = functions[i].type;
                        pProp->v.zVal = (char *)&pProp[1];
                        strncpy(pProp->v.zVal, zArg, nArg);
                        pProp->v.zVal[nArg] = '\0';
                    }

                    /* TODO: Dequote? */
                    break;
                }
            }
        }
    }

    for (i = 0; i < sizeof(keywords)/sizeof(struct KeywordFormat); i++) {
        if (0 == strncmp(keywords[i].zKeyword, z, n)) {
            pProp = (CssProperty *)ckalloc(sizeof(CssProperty));
            pProp->eType = keywords[i].type;
            break;
        }
    }

    /* Finally, treat the property as a generic string. */
    if (!pProp) {
        pProp = (CssProperty *)ckalloc(sizeof(CssProperty)+(n+1));
        pProp->eType = CSS_TYPE_STRING;
        pProp->v.zVal = (char *)&pProp[1];
        memcpy(pProp->v.zVal, z, n);
        pProp->v.zVal[n] = '\0';

        /* TODO: Dequote? */
    }
    return pProp;
}

/*
 *---------------------------------------------------------------------------
 *
 * HtmlCssStringToProperty --
 *
 *     This is an externally available interface to convert the property
 *     value string pointed to by z, length n, to a property object. The
 *     caller should call ckfree() on the return value when it has finished
 *     with it.
 *
 * Results:
 *     Allocated CssProperty object.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
CssProperty *HtmlCssStringToProperty(z, n)
    CONST char *z; 
    int n;
{
    CssToken sToken;
    if (n<0) {
        n = strlen(z);
    }
    sToken.z = z;
    sToken.n = n;
    return tokenToProperty(&sToken);
}

/*
 *---------------------------------------------------------------------------
 *
 * HtmlCssPropertyGetString --
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
CONST char *
HtmlCssPropertyGetString(pProp)
    CssProperty *pProp;
{
    static char zBuf[100];
    zBuf[0] = '\0';
    if (pProp) {
        switch (pProp->eType) {
            case CSS_TYPE_STRING:
                return pProp->v.zVal;
            case CSS_TYPE_EM:
                sprintf(zBuf, "%fem", pProp->v.rVal);
                break;
            case CSS_TYPE_PX:
                sprintf(zBuf, "%dpx", pProp->v.iVal);
                break;
            case CSS_TYPE_PT:
                sprintf(zBuf, "%dpt", pProp->v.iVal);
                break;
        }
    }
    return zBuf;
}


/*--------------------------------------------------------------------------
 *
 * PROPERTY_MASK_SET --
 * PROPERTY_MASK_GET --
 * PROPERTY_MASK_CNT --
 *
 *     Macros to deal with property set masks.
 *
 * Results:
 *
 * Side effects:
 *     None.
 *
 *--------------------------------------------------------------------------
 */
#define PROPERTY_MASK_SET(p,i) ((p)->a[(i>>5)&0x00000003]|=(1<<(i&0x0000001F)))
#define PROPERTY_MASK_GET(p,i) ((p)->a[(i>>5)&0x00000003]&(1<<(i&0x0000001F)))
#define PROPERTY_MASK_CNT(p,i) propertyMaskCnt(p, i)
static int propertyMaskCnt(p, i)
    CssPropertyMask *p;
    int i;
{
    int j;
    int r = 0;
    for(j=0; j<i; j++){
        if( PROPERTY_MASK_GET(p, j) ) r++;
    }
    return r;
}


/*--------------------------------------------------------------------------
 *
 * propertySetNew --
 *
 *     Allocate a new (empty) property set. The caller should eventually
 *     delete the property set using propertySetFree().
 *
 * Results:
 *     An empty property set.
 *
 * Side effects:
 *     None.
 *
 *--------------------------------------------------------------------------
 */
static CssPropertySet *propertySetNew(){
    CssPropertySet *p = (CssPropertySet *)ckalloc(sizeof(CssPropertySet));
    if( p ){
        memset(p, 0, sizeof(CssPropertySet));
    }
    return p;
}

/*--------------------------------------------------------------------------
 *
 * propertySetGet --
 *
 *     Retrieve CSS property 'i' if present in the property-set. 
 *
 * Results:
 *
 *     Return NULL if the property is not present, or a pointer to it's 
 *     string value if it is.
 *
 * Side effects:
 *     None.
 *
 *--------------------------------------------------------------------------
 */
static CssProperty *propertySetGet(p, i)
    CssPropertySet *p;         /* Property set */
    int i;                     /* Property id (i.e CSS_PROPERTY_WIDTH) */
{
    CssProperty *zRet = 0;
    assert( i<128 && i>=0 );
    if( PROPERTY_MASK_GET(&p->mask, i) ){
        zRet = p->aProp[PROPERTY_MASK_CNT(&p->mask, i)];
    }
    return zRet;
}

/*--------------------------------------------------------------------------
 *
 * propertySetAdd --
 *
 *     Insert or replace a value into a property set.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *--------------------------------------------------------------------------
 */
static void propertySetAdd(p, i, v)
    CssPropertySet *p;         /* Property set. */
    int i;                     /* Property id (i.e CSS_PROPERTY_WIDTH). */
    CssProperty *v;            /* Value for property. */
{
    assert( i<128 && i>=0 );

    if( PROPERTY_MASK_GET(&p->mask, i) ){
        int n = PROPERTY_MASK_CNT(&p->mask, i);
        ckfree((char *)p->aProp[n]);
        p->aProp[n] = v;
    }else{
        int n = p->nProp + 1;
        int s;
        int j;

        p->aProp = (CssProperty **)
                ckrealloc((char *)(p->aProp),(n)*(sizeof(CssProperty*)));
        PROPERTY_MASK_SET(&p->mask, i);
        s = PROPERTY_MASK_CNT(&p->mask, i);
        for (j=(n-1); j>s; j--) {
            p->aProp[j] = p->aProp[j-1];
        }
        p->aProp[s] = v;
        p->nProp = n;
    }
}

/*
 *---------------------------------------------------------------------------
 *
 * propertyDup --
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static CssProperty *propertyDup(pProp)
    CssProperty *pProp;
{
    CssProperty *pRet = (CssProperty *)ckalloc(sizeof(CssProperty));
    memcpy(pRet, pProp, sizeof(CssProperty));
    return pRet;
}

/*
 *---------------------------------------------------------------------------
 *
 * propertyIsLength --
 *
 *     Return true if the property passed as the first argument is a length
 *     property. (i.e. pixels, em, percentage etc.)
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static int propertyIsLength(pProp)
    CssProperty *pProp;
{
    return (
        pProp->eType==CSS_TYPE_EM ||
        pProp->eType==CSS_TYPE_PT ||
        pProp->eType==CSS_TYPE_PC ||
        pProp->eType==CSS_TYPE_EX ||
        pProp->eType==CSS_TYPE_PX ||
        pProp->eType==CSS_TYPE_PERCENT
    );
}

/*
 *---------------------------------------------------------------------------
 *
 * propertyIsString --
 *
 *     Return true if the property passed as the first argument is a
 *     string.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static int propertyIsString(pProp)
    CssProperty *pProp;
{
    return ( pProp->eType==CSS_TYPE_STRING );
}

/*
 *---------------------------------------------------------------------------
 *
 * getNextListItem --
 *
 *     Return the first property from a space seperated list of properties.
 *
 *     The property list is stored in string zList, length nList.
 *
 *     A pointer to the first property is returned. The length of the first
 *     property is stored in *pN.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static CONST char *getNextListItem(zList, nList, pN)
    CONST char *zList;
    int nList;
    int *pN;
{
    int n = 0;
    int t = CT_SPACE;
    CONST char *zRet = 0;
    CONST char *z = zList;
    CONST char *zEnd = zList+nList;

    while (z<zEnd && t==CT_SPACE) {
        t = cssGetToken(z, zEnd-z, &n);
        assert(n>0);
        if (t==CT_SPACE) {
            z += n;
        }
    }
    zRet = z;
    z += n;

    while (z<zEnd && t!=CT_SPACE) {
        int n2 = 0;
        t = cssGetToken(z, zEnd-z, &n2);
        assert(n2>0);
        z += n2;
        if (t!=CT_SPACE) {
            n += n2;
        }
    }

    if (zRet<zEnd && n>0) {
        assert(n<=nList);
        *pN = n;
        return zRet;
    }
    return 0;
}

/*
 *---------------------------------------------------------------------------
 *
 * propertySetAddShortcutBorder --
 *
 *     Devolve the shortcut property 'border' into it's sub-properties and
 *     add the results to a CssPropertySet.
 *
 *     A 'border' property consists of a white-space seperated list of at
 *     most three quantities. Any of the three quantities may be omitted,
 *     but the order remains the same.
 *
 *     [<border-width>] [<border-style>] [<border-color>]
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static void propertySetAddShortcutBorder(p, prop, v)
    CssPropertySet *p;         /* Property set. */
    int prop;
    CssToken *v;               /* Value for property. */
{
    CONST char *z = v->z;
    CONST char *zEnd = z + v->n;
    int n;

    int aWidth[] = {
        CSS_PROPERTY_BORDER_TOP_WIDTH,
        CSS_PROPERTY_BORDER_RIGHT_WIDTH,
        CSS_PROPERTY_BORDER_BOTTOM_WIDTH,
        CSS_PROPERTY_BORDER_LEFT_WIDTH,
    };
    int aStyle[] = {
        CSS_PROPERTY_BORDER_TOP_STYLE,
        CSS_PROPERTY_BORDER_RIGHT_STYLE,
        CSS_PROPERTY_BORDER_BOTTOM_STYLE,
        CSS_PROPERTY_BORDER_LEFT_STYLE,
    };
    int aColor[] = {
        CSS_PROPERTY_BORDER_TOP_COLOR,
        CSS_PROPERTY_BORDER_RIGHT_COLOR,
        CSS_PROPERTY_BORDER_BOTTOM_COLOR,
        CSS_PROPERTY_BORDER_LEFT_COLOR,
    };

    int iOffset = 0;        /* Offset in aWidth[], aStyle[], aColor[] */
    int nProp = 1;          /* Number of properties to set */
    switch (prop) {
        case CSS_SHORTCUTPROPERTY_BORDER:
            nProp = 4;
            break;
        case CSS_SHORTCUTPROPERTY_BORDER_TOP:
            break;
        case CSS_SHORTCUTPROPERTY_BORDER_RIGHT:
            iOffset = 1;
            break;
        case CSS_SHORTCUTPROPERTY_BORDER_BOTTOM:
            iOffset = 2;
            break;
        case CSS_SHORTCUTPROPERTY_BORDER_LEFT:
            iOffset = 3;
            break;
        default:
            assert(0);
    }

    while (z) {
        z = getNextListItem(z, zEnd-z, &n);
        if (z) {
            int *aProp = 0;
            CssToken token;
            CssProperty *pProp;
            int i;

            token.z = z;
            token.n = n;
            pProp = tokenToProperty(&token);

            if (propertyIsLength(pProp) || pProp->eType==CSS_TYPE_FLOAT) {
                aProp = aWidth;
            } else if (propertyIsString(pProp)) {
                struct BorderString {
                    CONST char *z;
                    int *a;
                } borderstring [] = {
                    {"none",   aStyle},
                    {"hidden", aStyle},
                    {"dotted", aStyle},
                    {"dashed", aStyle},
                    {"solid",  aStyle},
                    {"double", aStyle},
                    {"groove", aStyle},
                    {"ridge",  aStyle},
                    {"outset", aStyle},
                    {"inset", aStyle},
                    {"thin",   aWidth},
                    {"thick",  aWidth},
                    {"medium", aWidth},
                };
                int nB = sizeof(borderstring)/sizeof(struct BorderString);
                for (i=0; i < nB; i++) {
                    if (0==strcmp(pProp->v.zVal, borderstring[i].z)) {
                        aProp = borderstring[i].a;
                        break;
                    }
                }
                if (!aProp) {
                    aProp = aColor;
                }
            }

            if (aProp) {
                for (i = iOffset; i < iOffset+nProp; i++) {
                    if (i != iOffset) {
                        pProp = propertyDup(pProp);
                    }
                    propertySetAdd(p, aProp[i], pProp);
                }
            }
            
            assert(n>0);
            z += n;
        }
    }
}


/*
 *---------------------------------------------------------------------------
 *
 * propertySetAddShortcutBackground --
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static void 
propertySetAddShortcutBackground(p, v)
    CssPropertySet *p;         /* Property set */
    CssToken *v;               /* Value for 'background' property */
{
    CONST char *z= v->z;
    CONST char *zEnd = z + v->n;
    int n;
    int i;

    struct ReservedWord {
        CONST char *zWord;
        int property;
    } reserved [] = {
        {"scroll", CSS_PROPERTY_BACKGROUND_ATTACHMENT},
        {"fixed", CSS_PROPERTY_BACKGROUND_ATTACHMENT},
        {"repeat", CSS_PROPERTY_BACKGROUND_REPEAT},
        {"no-repeat", CSS_PROPERTY_BACKGROUND_REPEAT},
        {"repeat-y", CSS_PROPERTY_BACKGROUND_REPEAT},
        {"repeat-x", CSS_PROPERTY_BACKGROUND_REPEAT},
        {"top", CSS_PROPERTY_BACKGROUND_POSITION},
        {"left", CSS_PROPERTY_BACKGROUND_POSITION},
        {"right", CSS_PROPERTY_BACKGROUND_POSITION},
        {"bottom", CSS_PROPERTY_BACKGROUND_POSITION},
        {"center", CSS_PROPERTY_BACKGROUND_POSITION},
    };

    while (z) {
        CssProperty *pProp;
        z = getNextListItem(z, zEnd-z, &n);
        if (z) {
            CssToken token;
            token.z = z;
            token.n = n;
            pProp = tokenToProperty(&token);
            z += n;

            switch (pProp->eType) {
                case CSS_TYPE_STRING: {
                    int nReserved; 
                    nReserved = sizeof(reserved) / sizeof(struct ReservedWord);
                    for (i = 0; i < nReserved; i++) {
                        if (0==strcmp(pProp->v.zVal, reserved[i].zWord)) {
                            break;
                        }
                    }
                    if (i == nReserved) {
                        propertySetAdd(p, CSS_PROPERTY_BACKGROUND_COLOR, pProp);
                    } else {
                        propertySetAdd(p, reserved[i].property, pProp);
                    }
                    break;
                }
                case CSS_TYPE_URL:
                    propertySetAdd(p, CSS_PROPERTY_BACKGROUND_IMAGE, pProp);
                    break;
            }
        }
    }
}

/*
 *---------------------------------------------------------------------------
 *
 * propertySetAddShortcutBorderColor --
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static void propertySetAddShortcutBorderColor(p, prop, v)
    CssPropertySet *p;         /* Property set. */
    int prop;
    CssToken *v;               /* Value for property. */
{
    CONST char *z= v->z;
    CONST char *zEnd = z + v->n;
    int n;

    int i = 0;                 /* Index of apProp to read next color in to */
    CssProperty *apProp[4];    /* Array of color properties */
    memset(apProp, 0, sizeof(CssProperty *)*4);

    while (z && i<4) {
        z = getNextListItem(z, zEnd-z, &n);
        if (z) {
            CssToken token;
            token.z = z;
            token.n = n;
            apProp[i] = tokenToProperty(&token);
            i++;
            assert(n>0);
            z += n;
        }
    }

    switch (i) {
        case 1:
            apProp[1] = propertyDup(apProp[0]);
            apProp[2] = propertyDup(apProp[0]);
            apProp[3] = propertyDup(apProp[0]);
            break;
        case 2:
            apProp[2] = propertyDup(apProp[0]);
            apProp[3] = propertyDup(apProp[1]);
            break;
        case 3:
            apProp[3] = propertyDup(apProp[1]);
            break;
        case 4:
            break;
        default:
            return;
    }

    switch (prop) {
        case CSS_SHORTCUTPROPERTY_BORDER_COLOR:
            propertySetAdd(p, CSS_PROPERTY_BORDER_TOP_COLOR, apProp[0]);
            propertySetAdd(p, CSS_PROPERTY_BORDER_RIGHT_COLOR, apProp[1]);
            propertySetAdd(p, CSS_PROPERTY_BORDER_BOTTOM_COLOR, apProp[2]);
            propertySetAdd(p, CSS_PROPERTY_BORDER_LEFT_COLOR, apProp[3]);
            break;
        case CSS_SHORTCUTPROPERTY_BORDER_STYLE:
            propertySetAdd(p, CSS_PROPERTY_BORDER_TOP_STYLE, apProp[0]);
            propertySetAdd(p, CSS_PROPERTY_BORDER_RIGHT_STYLE, apProp[1]);
            propertySetAdd(p, CSS_PROPERTY_BORDER_BOTTOM_STYLE, apProp[2]);
            propertySetAdd(p, CSS_PROPERTY_BORDER_LEFT_STYLE, apProp[3]);
            break;
        case CSS_SHORTCUTPROPERTY_BORDER_WIDTH:
            propertySetAdd(p, CSS_PROPERTY_BORDER_TOP_WIDTH, apProp[0]);
            propertySetAdd(p, CSS_PROPERTY_BORDER_RIGHT_WIDTH, apProp[1]);
            propertySetAdd(p, CSS_PROPERTY_BORDER_BOTTOM_WIDTH, apProp[2]);
            propertySetAdd(p, CSS_PROPERTY_BORDER_LEFT_WIDTH, apProp[3]);
            break;
        case CSS_SHORTCUTPROPERTY_PADDING:
            propertySetAdd(p, CSS_PROPERTY_PADDING_TOP, apProp[0]);
            propertySetAdd(p, CSS_PROPERTY_PADDING_RIGHT, apProp[1]);
            propertySetAdd(p, CSS_PROPERTY_PADDING_BOTTOM, apProp[2]);
            propertySetAdd(p, CSS_PROPERTY_PADDING_LEFT, apProp[3]);
            break;
        case CSS_SHORTCUTPROPERTY_MARGIN:
            propertySetAdd(p, CSS_PROPERTY_MARGIN_TOP, apProp[0]);
            propertySetAdd(p, CSS_PROPERTY_MARGIN_RIGHT, apProp[1]);
            propertySetAdd(p, CSS_PROPERTY_MARGIN_BOTTOM, apProp[2]);
            propertySetAdd(p, CSS_PROPERTY_MARGIN_LEFT, apProp[3]);
            break;
    }
}

/*--------------------------------------------------------------------------
 *
 * propertySetFree --
 *
 *     Delete a property set and it's contents.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *--------------------------------------------------------------------------
 */
static void propertySetFree(CssPropertySet *p){
    int i;
    if( !p ) return;
    for(i=0; i<p->nProp; i++){
        ckfree((char *)p->aProp[i]);
    }
    ckfree((char *)p);
}

/*--------------------------------------------------------------------------
 *
 * propertySetFree --
 *
 *     Delete a linked list of CssSelector structs, including the 
 *     CssSelector.zValue and CssSelector.zAttr fields.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *--------------------------------------------------------------------------
 */
static void selectorFree(pSelector)
    CssSelector *pSelector;
{
    if( !pSelector ) return;
    selectorFree(pSelector->pNext);
    ckfree(pSelector->zValue);
    ckfree(pSelector->zAttr);
    ckfree((char *)pSelector);
}

/*
 *---------------------------------------------------------------------------
 *
 * cssGetToken --
 *
 *     Return the id of the next CSS token in the string pointed to by z,
 *     length n. The length of the token is written to *pLen. 0 is returned
 *     if there are no complete tokens remaining.
 *
 * Results:
 *     See above.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static int 
cssGetToken(z, n, pLen)
    CONST char *z; 
    int n; 
    int *pLen;
{
    if( n<=0 ){
      return 0;
    }

    *pLen = 1;
    switch( z[0] ){
        case ' ':
        case '\n':
        case '\t': return CT_SPACE;
        case '{':  return CT_LP;
        case '}':  return CT_RP;
        case ')':  return CT_RRP;
        case '[':  return CT_LSP;
        case ']':  return CT_RSP;
        case ';':  return CT_SEMICOLON;
        case ',':  return CT_COMMA;
        case ':':  return CT_COLON;
        case '+':  return CT_PLUS;
        case '>':  return CT_GT;
        case '*':  return CT_STAR;
        case '.':  return CT_DOT;
        case '#':  return CT_HASH;
        case '=':  return CT_EQUALS;
        case '~':  return CT_TILDE;
        case '|':  return CT_PIPE;
        case '/':  {
            int i;
            int c;
            if( z[1]!='*' || z[2]==0 ){
                return CT_SLASH;
            }
            for(i=3, c=z[2]; (c!='*' || z[i]!='/') && (c=z[i])!=0; i++){}
            if( c ) i++;
            *pLen = i;
            return -1;
        }

        case '"': case '\'': {
            char delim = z[0];
            char c;
            int i;
            for(i=1; i<n; i++){
                c = z[i];
                if( c=='\\' ){
                    i++;
                }
                if( c==delim ){
                    *pLen = i+1; 
                    return CT_STRING;
                }
            }
            *pLen = n;
            return -1;
        }

        case '@': {
            struct AtKeyWord {
                const char *z;
                int n;
                int t;
            } atkeywords[] = {
                {"import", 6, CT_IMPORT_SYM},
                {"page", 4, CT_PAGE_SYM},
                {"media", 5, CT_MEDIA_SYM},
                {"font-face", 9, CT_FONT_SYM},
                {"charset", 7, CT_CHARSET_SYM},
            };
            int i;
            for(i=0; i<sizeof(atkeywords)/sizeof(struct AtKeyWord); i++){
                if( 0==strncmp(&z[1], atkeywords[i].z, atkeywords[i].n) ){
                    *pLen = atkeywords[i].n + 1;
                    return atkeywords[i].t;
                }
            }
            goto bad_token;
        }
        case '!': {
            if( 0==strncmp(&z[1], "important", 9) ){
                 *pLen = 9 + 1;
                 return CT_IMPORTANT_SYM;
            }
            goto bad_token;
        }

        default: {
            /* This must be either an identifier or a function. For the
            ** ASCII character range 0-127, the 'charmap' array is 1 for
            ** characters allowed in an identifier or function name, 0
            ** for characters not allowed. Allowed characters are a-z, 
	    ** 0-9, '-', '_', '%' and '\'. All unicode characters
            ** outside the ASCII range are allowed.
            */
            static u8 charmap[128] = {
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0x00-0x0F */
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0x10-0x1F */
                0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, /* 0x20-0x2F */
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, /* 0x30-0x3F */
                0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* 0x40-0x4F */
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, /* 0x50-0x5F */
                0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* 0x60-0x6F */
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0  /* 0x70-0x7F */
            };
            int i;
            for(i=0; i<n && (z[i]<0 || charmap[(int)z[i]]); i++) /* empty */ ;
            if( i==0 ) goto bad_token;
            if( i<n && z[i]=='(' ){
                int t = -1;
                int tlen;
                i++;
                while( i!=n && t!=0 && t!=CT_RRP ){
                    t = cssGetToken(&z[i], n-i, &tlen);
                    i += tlen;
                }
                if( t!=CT_RRP ) goto bad_token;
                *pLen = i;
                return CT_FUNCTION;
            }
            *pLen = i;
            return CT_IDENT;
        }
             
    }

bad_token:
    *pLen = 1;
    return -1;
}

/* Versions of ckalloc() and ckfree() that are always functions (not macros). 
*/
static void * xCkalloc(size_t n){
    return ckalloc(n);
}
static void xCkfree(void *p){
    ckfree(p);
}

/*
 *---------------------------------------------------------------------------
 *
 * cssParse --
 *
 *     This routine does the work of parsing stylesheets or style
 *     attributes on behalf of HtmlCssParse() and HtmlCssParseStyle()
 *     respectively. 
 * 
 *     The first two argument identify the length of, and the text to be
 *     parsed.
 *
 *     The third argument is true if z points to the text of a style
 *     attribute, i.e: "color:red ; margin:0.4em". If false, then z points
 *     to an stylesheet, i.e. "H1 {text-size: 1.2em}". The stylesheet
 *     produced when parsing a style is the same as "* {<style text>}".
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
int cssParse(n, z, isStyle, origin, pStyleId, ppStyle)
    int n;                       /* Size of z in bytes */
    CONST char *z;               /* Text of attribute/document */
    int isStyle;                 /* True if this is a style attribute */
    int origin;                  /* CSS_ORIGIN_* value */
    Tcl_Obj *pStyleId;           /* Second and later parts of stylesheet id */
    CssStyleSheet **ppStyle;     /* IN/OUT: Stylesheet to append to   */
{
    CssParse sParse;
    CssToken sToken;
    void *p;
    int t;
    int c = 0;

    memset(&sParse, 0, sizeof(CssParse));
    sParse.origin = origin;
    sParse.pStyleId = pStyleId;

    if( n<0 ){
        n = strlen(z);
    }
    p = tkhtmlCssParserAlloc(xCkalloc);

    if (0==*ppStyle) {
        sParse.pStyle = (CssStyleSheet *)ckalloc(sizeof(CssStyleSheet));
        memset(sParse.pStyle, 0, sizeof(CssStyleSheet));
        Tcl_InitHashTable(&sParse.pStyle->rules, TCL_STRING_KEYS);
    } else {
        sParse.pStyle = *ppStyle;
    }

    if (isStyle) {
        /* If this is a style attribute, not a stylesheet, then feed the
         * parser the tokens '*' and '{' before attempting to parse the
         * style attribute text. After parsing the text, feed the parser a
         * '}' to finish everything off. Thus a style is converted to a
         * stylesheet with a rule, using the universal selector.
         */
         sToken.z = "*"; sToken.n = 1; 
         tkhtmlCssParser(p, CT_STAR, sToken, &sParse);
         sToken.z = "{"; sToken.n = 1; 
         tkhtmlCssParser(p, CT_LP, sToken, &sParse);
    }

    while( (t=cssGetToken(&z[c], n-c, &sToken.n)) ){
        sToken.z = &z[c];
        if( t>0 && t!=CT_IMPORTANT_SYM ){
            tkhtmlCssParser(p, t, sToken, &sParse);
        }
        c += sToken.n;
    }

    if (isStyle) {
         /* Closing '}' if this is a style, not a stylesheet (see above) */
         sToken.z = "}"; sToken.n = 1; 
         tkhtmlCssParser(p, CT_RP, sToken, &sParse);

         /* Todo: The parser seems to need one more token to work... */
         sToken.z = " "; sToken.n = 1; 
         tkhtmlCssParser(p, CT_SPACE, sToken, &sParse);
    }

    *ppStyle = sParse.pStyle;
    tkhtmlCssParserFree(p, xCkfree);

    return 0;
}

/*--------------------------------------------------------------------------
 *
 * HtmlCssParse --
 *
 *     Parse the stylesheet pointed to by z, length n bytes. See comments
 *     above cssParse() for more detail.
 *
 * Results:
 *
 *     Returns a CssStyleSheet pointer, written to *ppStyle.
 *
 * Side effects:
 *
 *--------------------------------------------------------------------------
 */
int HtmlCssParse(pText, origin, pStyleId, ppStyle)
    Tcl_Obj *pText;
    int origin;
    Tcl_Obj *pStyleId;
    CssStyleSheet **ppStyle;
{
    int n;
    CONST char *z;
    z = Tcl_GetStringFromObj(pText, &n);
    return cssParse(n, z, 0, origin, pStyleId, ppStyle);
}

/*--------------------------------------------------------------------------
 *
 * HtmlCssParseStyle --
 *
 *     Parse the style attribute value pointed to by z, length n bytes. See
 *     comments above cssParse() for more detail.
 *
 * Results:
 *
 *     Returns a CssStyleSheet pointer, written to *ppStyle.
 *
 * Side effects:
 *
 *--------------------------------------------------------------------------
 */
int HtmlCssParseStyle(
    int n,
    const char *z,
    CssProperties **ppProperties
){
    CssStyleSheet *pStyle = 0;
    assert(ppProperties && !(*ppProperties));
    cssParse(n, z, 1, 0, 0, &pStyle);
    if (pStyle && pStyle->pUniversalRules) {
        propertiesAdd(ppProperties, pStyle->pUniversalRules);
    }
    /* Todo: Clean up pStyle. */
    return 0;
}

void HtmlCssStyleSheetFree(CssStyleSheet *pStyle){
    /* TODO: Cleanup! */
}

/*
** Return the number of syntax errors that occured while parsing the
** style-sheet.
*/
int HtmlCssStyleSheetSyntaxErrs(CssStyleSheet *pStyle){
    return pStyle->nSyntaxErr;
}

/*--------------------------------------------------------------------------
 *
 * tkhtmlCssDeclaration --
 *
 *     This function is called by the CSS parser when it parses a property 
 *     declaration (i.e "<property> : <expression>").
 *
 * Results:
 *     None.
 *
 * Side effects:
 *
 *--------------------------------------------------------------------------
 */
void tkhtmlCssDeclaration(CssParse *pParse, CssToken *pProp, CssToken *pExpr){
    int prop; 
    char zBuf[64];

#if TRACE_PARSER_CALLS
    printf("tkhtmlCssDeclaration(%p, \"%.*s\", \"%.*s\")\n", 
        pParse,
        pProp?pProp->n:0, pProp?pProp->z:"", 
        pExpr?pExpr->n:0, pExpr?pExpr->z:""
    );
#endif

    /* Resolve the property name. If we don't recognize it, then ignore
     * the entire declaration (CSS2 spec says to do this).
     */
    strncpy(zBuf, pProp->z, MIN(pProp->n, 63));
    zBuf[63] = 0;
    Tcl_UtfToLower(zBuf);
    prop = tkhtmlCssPropertyFromString(MIN(63, pProp->n), zBuf);
    if( prop<0 ) return;
    if( !pParse->pPropertySet ){
        pParse->pPropertySet = propertySetNew();
    }

    switch (prop) {
        case CSS_SHORTCUTPROPERTY_BORDER:
        case CSS_SHORTCUTPROPERTY_BORDER_LEFT:
        case CSS_SHORTCUTPROPERTY_BORDER_RIGHT:
        case CSS_SHORTCUTPROPERTY_BORDER_TOP:
        case CSS_SHORTCUTPROPERTY_BORDER_BOTTOM:
            propertySetAddShortcutBorder(pParse->pPropertySet, prop, pExpr);
            break;
        case CSS_SHORTCUTPROPERTY_BORDER_COLOR:
        case CSS_SHORTCUTPROPERTY_BORDER_STYLE:
        case CSS_SHORTCUTPROPERTY_BORDER_WIDTH:
        case CSS_SHORTCUTPROPERTY_PADDING:
        case CSS_SHORTCUTPROPERTY_MARGIN:
            propertySetAddShortcutBorderColor(pParse->pPropertySet,prop,pExpr);
            break;
        case CSS_SHORTCUTPROPERTY_BACKGROUND:
            propertySetAddShortcutBackground(pParse->pPropertySet, pExpr);
            break;
        default:
            propertySetAdd(pParse->pPropertySet, prop, tokenToProperty(pExpr));
    }
}


static void dequote(z)
    char *z;
{
    int n;
    if (!z) return;
    n = strlen(z);
    if (z[0]=='"' && z[n-1]=='"') {
        int i;
        for (i=0; i<(n-2); i++) {
             z[i] = z[i+1];
        }
        z[n-2] = '\0';
    }
}


/*--------------------------------------------------------------------------
 *
 * tkhtmlCssSelector --
 *
 *     This is called whenever a simple selector is parsed. 
 *     i.e. "H1" or ":before".
 *
 * Results:
 *     None.
 *
 * Side effects:
 *
 *--------------------------------------------------------------------------
 */
void tkhtmlCssSelector(pParse, stype, pAttr, pValue)
    CssParse *pParse; 
    int stype; 
    CssToken *pAttr; 
    CssToken *pValue;
{
    CssSelector *pSelector;

#if TRACE_PARSER_CALLS
    /* I used this to make sure the parser was passing the components of
     * selectors to this function in the correct order. Once this was 
     * verified, it is not particularly useful trace output. But we'll leave
     * it here for the time being in case something comes up.
     */
    printf("tkhtmlCssSelector(%p, %s, \"%.*s\", \"%.*s\")\n", 
        pParse, constantToString(stype), 
        pAttr?pAttr->n:0, pAttr?pAttr->z:"", 
        pValue?pValue->n:0, pValue?pValue->z:""
    );
#endif

    pSelector = (CssSelector *)ckalloc(sizeof(CssSelector));
    memset(pSelector, 0, sizeof(CssSelector));
    pSelector->eSelector = stype;
    pSelector->zValue = tokenToString(pValue);
    dequote(pSelector->zValue);
    pSelector->zAttr = tokenToString(pAttr);
    pSelector->pNext = pParse->pSelector;
    pParse->pSelector = pSelector;

    /* Tag names are case-insensitive - fold to lower case */
    if( stype==CSS_SELECTOR_TYPE ){
        assert(pSelector->zValue);
        Tcl_UtfToLower(pSelector->zValue);
    }
}

/*
 *---------------------------------------------------------------------------
 *
 * ruleCompare --
 *
 *     Compare the priority of two rule objects. Return greater than zero
 *     if the priority of pLeft is higher, zero if the two rules have the
 *     same priority, and negative if pRight has higher priority. i.e.:
 *
 *         PRIORITY(pLeft) - PRIORITY(pRight)
 *
 *     This function is used to determine the order of rules in the
 *     rules CssRule.pNext linked list.
 *
 * Results:
 *     See above.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static int 
ruleCompare(CssRule *pLeft, CssRule *pRight) {
    int res = 0;
    assert(pLeft && pRight);

    if (res == 0) {
        res = pLeft->origin - pRight->origin;
    }
    if (res == 0) {
        res = pLeft->specificity - pRight->specificity;
    }
    if (res == 0) {
        char *zLeft = Tcl_GetString(pLeft->pStyleId);
        char *zRight = Tcl_GetString(pRight->pStyleId);
        res = strcmp(zLeft, zRight);
    }
    return res;
}

/*
 *---------------------------------------------------------------------------
 *
 * cssSelectorPropertySetPair --
 *
 *     A rule has just been parsed with selector pSelector and properties
 *     pPropertySet. This function creates a CssRule object to link the two
 *     together and inserts the new rule into the CssStyleSheet structure.
 *
 *     The caller should not free resources associated with pSelector or
 *     pPropertySet after this function returns, they are now linked into
 *     the stylesheet object.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
void 
cssSelectorPropertySetPair(pParse, pSelector, pPropertySet)
    CssParse *pParse;
    CssSelector *pSelector;
    CssPropertySet *pPropertySet;
{
    int spec = 0;
    CssSelector *pS = 0;
    CssStyleSheet *pStyle = pParse->pStyle;
    CssRule *pRule = (CssRule *)ckalloc(sizeof(CssRule));
    memset(pRule, 0, sizeof(CssRule));

    pPropertySet->nRef++;
    pRule->pImportant = 0;

    /* Calculate the specificity of the rules. We use the following
     * formala:
     *
     *     Specificity = (number of id selectors)        * 10000 +
     *                   (number of attribute selectors) * 100   +
     *                   (number of pseudo classes)      * 100   +
     *                   (number of type selectors)
     *
     * Todo: There are (at least) two bugs here:
     *     1. A rule with 100 type selectors has greater specificity than a
     *        rule with a single attribute selector. This probably isn't a
     *        problem.
     *     2. A selector of the form '[id="hello"]' has the same
     *        specificity as the selector '.hello'. This is pretty obscure,
     *        but could come up.
     * 
     * See section 6.4, "The cascade", of CSS2 documentation for details on
     * selector specificity.
     */
    for (pS=pSelector; pS; pS = pS->pNext) {
         switch (pS->eSelector) {
             case CSS_SELECTOR_TYPE:
                 spec += 1;
                 break;
             case CSS_SELECTOR_ATTR:
             case CSS_SELECTOR_ATTRVALUE:
             case CSS_SELECTOR_ATTRLISTVALUE:
             case CSS_SELECTOR_ATTRHYPHEN:
                 if (0==strcmp(pS->zAttr, "id")) {
                     spec += 10000;
                     break;
                 }
             case CSS_PSEUDOCLASS_LANG:
             case CSS_PSEUDOCLASS_FIRSTCHILD:
             case CSS_PSEUDOCLASS_LINK:
             case CSS_PSEUDOCLASS_VISITED:
             case CSS_PSEUDOCLASS_ACTIVE:
             case CSS_PSEUDOCLASS_HOVER:
             case CSS_PSEUDOCLASS_FOCUS:
                 spec += 100;
                 break;
         }
    }
    pRule->specificity = spec;
    pRule->origin = pParse->origin;
    pRule->pStyleId = pParse->pStyleId;
    if (pRule->pStyleId) {
        Tcl_IncrRefCount(pRule->pStyleId);
    }

    if( 0 && pSelector->eSelector==CSS_SELECTOR_TYPE ){
        Tcl_HashEntry *pEntry; 
        int n;         /* True if we add a a new hash table entry */
        assert( pSelector->zValue );
        pEntry = Tcl_CreateHashEntry(&pStyle->rules, pSelector->zValue, &n);
        pRule->pNext = Tcl_GetHashValue(pEntry);
        assert( (n && !pRule->pNext) || (!n && pRule->pNext) );
        Tcl_SetHashValue(pEntry, pRule);
    }else{
        /* The rule doesn't belong in any hash table, so put it in the
         * default list.
         */
        CssRule *pR = pStyle->pUniversalRules;

        if (!pR || ruleCompare(pR, pRule)<=0) {
            /* If the default list is currently empty, or the rule being
	     * added has higher priority than the first rule in the list,
             * our rule becomes the new head of the list.
             */
	    pRule->pNext = pStyle->pUniversalRules;
            pStyle->pUniversalRules = pRule;
        } else {
            /* Otherwise insert the new rule into the list, ordered by
             * priority. If there exists another rule with the same
             * priority, then this rule is inserted into the list *before*
             * it. This is because when rules are of equal priority, the
             * latter specified wins.
             */
            while (pR->pNext && ruleCompare(pR->pNext, pRule)>0 ) {
                pR = pR->pNext;
            }
            pRule->pNext = pR->pNext;
            pR->pNext = pRule;
        }
    }

    pRule->pSelector = pSelector;
    pRule->pPropertySet = pPropertySet;
}

int tkhtmlCssPseudo(pToken)
    CssToken *pToken;
{
    char *zOptions[] = {"link", "visited"};
    int eOptions[] = {CSS_PSEUDOCLASS_LINK, CSS_PSEUDOCLASS_VISITED};
    int i;

    for (i=0; i<sizeof(zOptions)/sizeof(char *); i++) {
        if (pToken->n==strlen(zOptions[i]) && 
                0==strncmp(pToken->z, zOptions[i], pToken->n)) {
            return eOptions[i];
        }
    }
    return CSS_PSEUDOCLASS_LANG;
}

/*--------------------------------------------------------------------------
 *
 * tkhtmlCssRule --
 *
 *     This is called when the parser has parsed an entire rule.
 *
 * Results:
 *     None.
 *
 * Side effects:
 * 
 *     If the parse was successful, then add the rule to the stylesheet.
 *     If unsuccessful, delete anything that was built up by calls to 
 *     tkhtmlCssDeclaration() or tkhtmlCssSelector().
 *
 *--------------------------------------------------------------------------
 */
void tkhtmlCssRule(pParse, success)
    CssParse *pParse;
    int success;
{
    CssSelector *pSelector = pParse->pSelector;
    CssPropertySet *pPropertySet = pParse->pPropertySet;
    CssSelector **apXtraSelector = pParse->apXtraSelector;
    int nXtra = pParse->nXtra;
    int i;

    pParse->pSelector = 0;
    pParse->pPropertySet = 0;
    pParse->apXtraSelector = 0;
    pParse->nXtra = 0;

    if( success && pSelector && pPropertySet ){
        cssSelectorPropertySetPair(pParse, pSelector, pPropertySet);
        for (i = 0; i < nXtra; i++){
            cssSelectorPropertySetPair(pParse, apXtraSelector[i], pPropertySet);
        }
    }else{
        /* Some sort of a parse error has occured. We won't be including
         * this rule, so just free these structs so we don't leak memory.
         */ 
        selectorFree(pSelector);
        propertySetFree(pPropertySet);
        for (i = 0; i < nXtra; i++){
            selectorFree(apXtraSelector);
        }
    }

    if( apXtraSelector ){
        ckfree((char *)apXtraSelector);
    }
}

/*--------------------------------------------------------------------------
 *
 * attrTest --
 *
 *     Test if an attribute value matches a string. The three modes of 
 *     comparing attribute values specified in CSS are supported.
 *
 * Results:
 *     Non-zero is returned if the match is true.
 *
 * Side effects:
 *     None.
 *
 *--------------------------------------------------------------------------
 */
static int attrTest(eType, zString, zAttr)
    u8 eType;
    const char *zString;
    const char *zAttr;
{
    if (!zAttr) {
        return 0;
    }

    switch( eType ){
        /* True if the specified attribute exists */
        case CSS_SELECTOR_ATTR:
            return (zAttr?1:0);

        /* True if the specified attribute exists and the value matches
         * the string exactly.
         */
        case CSS_SELECTOR_ATTRVALUE:
            return ((zAttr && 0==strcasecmp(zAttr, zString))?1:0);

	/* Treat the attribute value (if it exists) as a space seperated list.
         * Return true if zString exists in the list.
         */
        case CSS_SELECTOR_ATTRLISTVALUE: {
            const char *pAttr = zAttr;
            int nAttr;
            int nString = strlen(zString);
            while (pAttr=getNextListItem(pAttr, strlen(pAttr), &nAttr)) {
                if (nString==nAttr && 0==strncasecmp(pAttr, zString, nAttr)) {
                    return 1;
                }
                pAttr += nAttr;
            }
            return 0;
        }

        /* True if the attribute exists and matches zString up to the
         * first '-' character in the attribute value.
         */
        case CSS_SELECTOR_ATTRHYPHEN: {
            char *pHyphen = strchr(zAttr, '-');
            if( pHyphen && 0==strncasecmp(zAttr, zString, pHyphen-zAttr) ){
                return 1;
            }
            return 0;
        }
    }

    assert(!"Impossible");
    return 0;
}

/*--------------------------------------------------------------------------
 *
 * selectorTest --
 *
 *     Test if a selector matches a document node.
 *
 * Results:
 *     Non-zero is returned if the Selector does match the node.
 *
 * Side effects:
 *     None.
 *
 *--------------------------------------------------------------------------
 */
#define NODE_TYPE(x)        (pNodeInterface->xType(x))
#define NODE_ATTR(x,y)      (pNodeInterface->xAttr(x,y))
#define NODE_PARENT(x)      (pNodeInterface->xParent(x))
#define NODE_NUMCHILDREN(x) (pNodeInterface->xNumChildren(x))
#define NODE_CHILD(x,y)     (pNodeInterface->xChild(x,y))
#define NODE_PARENTIDX(x)   (pNodeInterface->xParentIdx(x))
#define NODE_LANG(x)        (pNodeInterface->xLang(x))
static int selectorTest(pSelector, pNodeInterface, pNode)
    CssSelector *pSelector;
    CssNodeInterface *pNodeInterface;
    void *pNode;
{
    CssSelector *p = pSelector;
    void *x = pNode;
    while( p && x ){

        switch( p->eSelector ){
            case CSS_SELECTOR_UNIVERSAL:
                break;

            case CSS_SELECTOR_TYPE:
                if( strcmp(NODE_TYPE(x), p->zValue) ) return 0;
                break;

            case CSS_SELECTOR_ATTR:
            case CSS_SELECTOR_ATTRVALUE:
            case CSS_SELECTOR_ATTRLISTVALUE:
            case CSS_SELECTOR_ATTRHYPHEN:
                if( !attrTest(p->eSelector, p->zValue, NODE_ATTR(x,p->zAttr)) ){
                    return 0;
                }
                break;

            case CSS_SELECTORCHAIN_DESCENDANT: {
                void *pParent = NODE_PARENT(x);
                CssSelector *pNext = p->pNext;
                while (pParent) {
                    if (selectorTest(pNext, pNodeInterface, pParent)) {
                        return 1;
                    }
                    pParent = NODE_PARENT(pParent);
                }
                return 0;
            }
            case CSS_SELECTORCHAIN_CHILD:
                x = NODE_PARENT(x);
                break;
            case CSS_SELECTORCHAIN_ADJACENT: {
                int n = NODE_PARENTIDX(x);
                if( n<=0 ) return 0;
                x = NODE_CHILD(NODE_PARENT(x), n-1);
                break;
            }
                
            /* TODO: Support pseudo elements and classes properly. The
             * really important ones are ":visited" and ":link". ":active",
             * ":hover" and ":focus" are also pretty crucial to rendering
             * the web correctly.
             */
            case CSS_PSEUDOCLASS_LANG:
            case CSS_PSEUDOCLASS_FIRSTCHILD:
                return 0;
            case CSS_PSEUDOCLASS_LINK:
                /* Psuedo-class ":link". This rule matches any element with
                 * tag-type <a> and an href attribute.
                 */
                if (strcmp(NODE_TYPE(x), "a") ||
                    !attrTest(CSS_SELECTOR_ATTR, 0, NODE_ATTR(x,"href"))
                ) {
                    return 0;
                }
                break;
            case CSS_PSEUDOCLASS_VISITED:
            case CSS_PSEUDOCLASS_ACTIVE:
            case CSS_PSEUDOCLASS_HOVER:
            case CSS_PSEUDOCLASS_FOCUS:
            case CSS_PSEUDOELEMENT_FIRSTLINE:
            case CSS_PSEUDOELEMENT_FIRSTLETTER:
            case CSS_PSEUDOELEMENT_BEFORE:
            case CSS_PSEUDOELEMENT_AFTER:
                return 0;

            case CSS_SELECTOR_NEVERMATCH:
                return 0;

            default:
                assert(!"Impossible");
        }
        p = p->pNext;
    }

    return (x && !p)?1:0;
}

static void propertiesAdd(ppProperties, pRule)
    CssProperties **ppProperties;
    CssRule *pRule;
{
    CssProperties *pProperties = *ppProperties;
    int n = (pProperties?pProperties->nRule:0) + 1;
    int nAlloc = sizeof(CssProperties) + n*sizeof(CssRule *);

    assert( pRule );

    pProperties = (CssProperties *)ckrealloc((char *)pProperties, nAlloc);
    pProperties->nRule = n;
    pProperties->apRule = (CssRule **)&pProperties[1];
    pProperties->apRule[n-1] = pRule;

    *ppProperties = pProperties;
}

void HtmlCssPropertiesFree(pPropertySet)
    CssProperties *pPropertySet;
{
    ckfree((char *)pPropertySet);
}

/*--------------------------------------------------------------------------
 *
 * HtmlCssStyleSheetApply --
 *
 * Results:
 *
 * Side effects:
 *
 *--------------------------------------------------------------------------
 */
void HtmlCssStyleSheetApply(pStyle, pNodeInterface, pNode, ppProperties)
    CssStyleSheet * pStyle; 
    CONST CssNodeInterface *pNodeInterface;
    void *pNode; 
    CssProperties **ppProperties;
{
    CssRule *pRule = 0;
    CssRule *pRule2 = 0;
    Tcl_HashEntry *pEntry;

    /* For each rule in the style-sheets hash table for the given node-type,
     * see if the selector matches the node. If so, add the rules properties
     * to the property set.
     */
    pEntry = Tcl_FindHashEntry(&pStyle->rules, NODE_TYPE(pNode));
    if( pEntry ){
        pRule = (CssRule *)Tcl_GetHashValue(pEntry);
    }
    pRule2 = pStyle->pUniversalRules;
    if( !pRule ){
        pRule = pRule2;
        pRule2 = 0;
    }

    while( pRule ){
        int match = selectorTest(pRule->pSelector, pNodeInterface, pNode);
        CssPropertySet *pPropertySet = pRule->pPropertySet;

#if TRACE_STYLE_APPLICATION
        printf("Rule %p does %s node - ", pRule, match?"match":"NOT match");
        for(i=0; i<127; i++){
            const char *z = propertySetGet(pPropertySet, i);
            if( z ){
                printf("%s=\"%s\" ", tkhtmlCssPropertyToString(i), z);
            }
        }
        printf("\n");
#endif

        if (match) {
            propertiesAdd(ppProperties, pRule);
        }

        /* Advance pRule to the next rule */
        pRule = pRule->pNext;
        if( !pRule ){
            pRule = pRule2;
            pRule2 = 0;
        }
    }
}

/*--------------------------------------------------------------------------
 *
 * HtmlCssPropertiesGet --
 *     Retrieve the value of a specified property from a CssProperties
 *     object, or NULL if the property is not defined.
 *
 * Results:
 *
 * Side effects:
 *
 *--------------------------------------------------------------------------
 */
CssProperty *
HtmlCssPropertiesGet(pProperties, prop)
    CssProperties * pProperties; 
    int prop;
{
    CssProperty *zRet = 0;
    if( pProperties ){
        int i;
        for(i=0; i<pProperties->nRule && !zRet; i++){
            CssPropertySet *pPropertySet = pProperties->apRule[i]->pPropertySet;
            zRet = propertySetGet(pPropertySet, prop);
        }
    }
    return zRet;
}

/*--------------------------------------------------------------------------
 *
 * HtmlCssPropertiesGet2 --
 *     Retrieve the value of a specified property from a CssProperties
 *     object, or NULL if the property is not defined.
 *
 * Results:
 *
 * Side effects:
 *
 *--------------------------------------------------------------------------
 */
CssProperty *
HtmlCssPropertiesGet2(pProperties, prop, pSheetnum, pSpec)
    CssProperties * pProperties; 
    int prop;
    int *pSheetnum;
    int *pSpec;
{
    CssProperty *zRet = 0;
    if( pProperties ){
        int i;
        for(i=0; i<pProperties->nRule && !zRet; i++){
            CssPropertySet *pPropertySet = pProperties->apRule[i]->pPropertySet;
            zRet = propertySetGet(pPropertySet, prop);
            if (zRet) {
                if( pSheetnum ) *pSheetnum = pProperties->apRule[i]->origin;
                if( pSpec ) *pSpec = pProperties->apRule[i]->specificity;
            }
        }
    }
    return zRet;
}

/*
 *---------------------------------------------------------------------------
 *
 * HtmlCssSelectorComma --
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
void HtmlCssSelectorComma(pParse)
    CssParse *pParse;
{
    int n = (pParse->nXtra + 1) * sizeof(CssSelector *);
    pParse->apXtraSelector = 
       (CssSelector **)ckrealloc((char *)pParse->apXtraSelector, n);
    pParse->apXtraSelector[pParse->nXtra] = pParse->pSelector;
    pParse->pSelector = 0;
    pParse->nXtra++;
}

/*
 *---------------------------------------------------------------------------
 *
 * HtmlCssPropertiesTclize --
 * 
 *     Create a Tcl representation of a property set. This is returned
 *     as a new Tcl object with the ref-count set to 1. The caller must
 *     call Tcl_DecrRefCount() on the returned object at some point.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
Tcl_Obj * HtmlCssPropertiesTclize(pProperties)
    CssProperties * pProperties; 
{
    Tcl_Obj *pRet = Tcl_NewObj();
    int i;
    Tcl_IncrRefCount(pRet);
    if( pProperties ){
        for(i=0; i<127; i++){
            CssProperty *pProp = HtmlCssPropertiesGet(pProperties, i);
            if( pProp ){
                Tcl_ListObjAppendElement(0, pRet, 
                    Tcl_NewStringObj(tkhtmlCssPropertyToString(i), -1));
                Tcl_ListObjAppendElement(0, pRet, 
                    Tcl_NewStringObj(HtmlCssPropertyGetString(pProp), -1));
            }
        }
    }
    return pRet;
}
