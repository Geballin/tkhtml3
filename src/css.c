/*
 * Copyright (c) 2005 Eolas Technologies Inc.
 * All rights reserved.
 *
 * This Open Source project was made possible through the financial support
 * of Eolas Technologies Inc.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the <ORGANIZATION> nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 *    The CSS "cascade":
 *
 *        1. Find all declarations that apply to the element/property in
 *           question.  Declarations apply if the selector matches the
 *           element in question. If no declarations apply, the inherited
 *           value is used. If there is no inherited value (this is the
 *           case for the 'HTML' element and for properties that do not
 *           inherit), the initial value is used. 
 *       
 *        2. Sort the declarations by explicit weight: declarations marked
 *           '!important' carry more weight than unmarked (normal)
 *           declarations.  
 * 
 *        3. Sort by origin: the author's style sheets override the
 *           reader's style sheet which override the UA's default values.
 *           An imported style sheet has the same origin as the style sheet
 *           from which it is imported. 
 *
 *        4. Sort by specificity of selector: more specific selectors will
 *           override more general ones. To find the specificity, count the
 *           number of ID attributes in the selector (a), the number of
 *           CLASS attributes in the selector (b), and the number of tag
 *           names in the selector (c). Concatenating the three numbers (in
 *           a number system with a large base) gives the specificity. Some
 *           examples:
 *
 *        5. Sort by order specified: if two rules have the same weight,
 *           the latter specified wins. Rules in imported style sheets are
 *           considered to be before any rules in the style sheet itself.
 *
 *     As well as rules specified as part of stylesheets, property values
 *     may also come from:
 * 
 *           * Html style attributes. (i.e. <p style="...">). These
 *             properties are treated as if they were specified at the end
 *             of the author stylesheet with a single "id" selector.
 *
 *           * Other html attributes. (i.e. <p font="...">). These
 *             properties are treated as if they occured at the start of
 *             the author stylesheet with a single "type" selector.
 */

#include <stdlib.h>
#include <tcl.h>
#include <string.h>
#include <assert.h>
#include <stdio.h>
#include <errno.h>
#include <ctype.h>

#include "css.h"
#include "cssInt.h"
#include "html.h"

/*
 * Macros to trace code in this file. Set to non-zero to activate trace
 * output on stdout.
 */
#define TRACE_PARSER_CALLS 0
#define TRACE_STYLE_APPLICATION 0
#define TRACE_PROPERTY_PARSE 0

/* Declarations for the parser functions generated by lemon. These are used
 * by HtmlCssParse() and HtmlCssParseStyle().
 */
void *tkhtmlCssParserAlloc(void *(*)(size_t));
void tkhtmlCssParser(void *, int, CssToken, CssParse*);
void tkhtmlCssParserFree(void *, void (*)(void *));

static void propertiesAdd(CssProperties **, CssRule *);
static int cssGetToken(CONST char *, int , int *);

/*
 *---------------------------------------------------------------------------
 *
 * constantToString --
 *
 *     Transform an integer constant to it's string representation (for
 *     debugging). All of the constants defined in cssInt.h that start with
 *     CSS_* are supported.
 *
 * Results:
 *     Pointer to a static string.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
#if TRACE_PARSER_CALLS
static const char *constantToString(int c){
    switch( c ){
        case CSS_SELECTORCHAIN_DESCENDANT: 
            return "CSS_SELECTORCHAIN_DESCENDANT";
        case CSS_SELECTORCHAIN_CHILD: 
            return "CSS_SELECTORCHAIN_CHILD";
        case CSS_SELECTORCHAIN_ADJACENT: 
            return "CSS_SELECTORCHAIN_ADJACENT";
        case CSS_SELECTOR_UNIVERSAL: 
            return "CSS_SELECTOR_UNIVERSAL";
        case CSS_SELECTOR_TYPE: 
            return "CSS_SELECTOR_TYPE";
        case CSS_SELECTOR_ATTR: 
            return "CSS_SELECTOR_ATTR";
        case CSS_SELECTOR_ATTRVALUE: 
            return "CSS_SELECTOR_ATTRVALUE";
        case CSS_SELECTOR_ATTRLISTVALUE: 
            return "CSS_SELECTOR_ATTRLISTVALUE";
        case CSS_SELECTOR_ATTRHYPHEN: 
            return "CSS_SELECTOR_ATTRHYPHEN";
        case CSS_PSEUDOCLASS_LANG: 
            return "CSS_PSEUDOCLASS_LANG";
        case CSS_PSEUDOCLASS_FIRSTCHILD: 
            return "CSS_PSEUDOCLASS_FIRSTCHILD";
        case CSS_PSEUDOCLASS_LINK:  
            return "CSS_PSEUDOCLASS_LINK";
        case CSS_PSEUDOCLASS_VISITED: 
            return "CSS_PSEUDOCLASS_VISITED";
        case CSS_PSEUDOCLASS_ACTIVE:  
            return "CSS_PSEUDOCLASS_ACTIVE";
        case CSS_PSEUDOCLASS_HOVER: 
            return "CSS_PSEUDOCLASS_HOVER";
        case CSS_PSEUDOCLASS_FOCUS: 
            return "CSS_PSEUDOCLASS_FOCUS";
        case CSS_PSEUDOELEMENT_FIRSTLINE: 
            return "CSS_PSEUDOELEMENT_FIRSTLINE";
        case CSS_PSEUDOELEMENT_FIRSTLETTER: 
            return "CSS_PSEUDOELEMENT_FIRSTLETTER";
        case CSS_PSEUDOELEMENT_BEFORE: 
            return "CSS_PSEUDOELEMENT_BEFORE";
        case CSS_PSEUDOELEMENT_AFTER: 
            return "CSS_PSEUDOELEMENT_AFTER";
        case CSS_MEDIA_ALL: 
            return "CSS_MEDIA_ALL";
        case CSS_MEDIA_AURAL: 
            return "CSS_MEDIA_AURAL";
        case CSS_MEDIA_BRAILLE: 
            return "CSS_MEDIA_BRAILLE";
        case CSS_MEDIA_EMBOSSED: 
            return "CSS_MEDIA_EMBOSSED";
        case CSS_MEDIA_HANDHELD: 
            return "CSS_MEDIA_HANDHELD";
        case CSS_MEDIA_PRINT: 
            return "CSS_MEDIA_PRINT";
        case CSS_MEDIA_PROJECTION: 
            return "CSS_MEDIA_PROJECTION";
        case CSS_MEDIA_SCREEN: 
            return "CSS_MEDIA_SCREEN";
        case CSS_MEDIA_TTY: 
            return "CSS_MEDIA_TTY";
        case CSS_MEDIA_TV: 
            return "CSS_MEDIA_TV";
    }
    return "unknown";
}
#endif

/*--------------------------------------------------------------------------
 *
 * tokenToString --
 *
 *     This function returns a null-terminated string (allocated by ckalloc)
 *     populated with the contents of the supplied token.
 *
 * Results:
 *     Null-terminated string. Caller is responsible for calling ckfree()
 *     on it.
 *
 * Side effects:
 *     None.
 *
 *--------------------------------------------------------------------------
 */
static char *tokenToString(CssToken *pToken){
    char *zRet;
    if( !pToken || pToken->n<=0 ){
         return 0;
    }
    zRet = (char *)ckalloc(pToken->n+1);
    memcpy(zRet, pToken->z, pToken->n);
    zRet[pToken->n] = '\0';
    return zRet;
}

/*
 *---------------------------------------------------------------------------
 *
 * tokenToReal --
 *
 *     Try to convert the token pToken to a floating point number. The
 *     conversion is considered successful if pToken starts with anything
 *     that looks like a floating point number. "0.0px" and "0px" convert
 *     successfully, "px" does not. Return non-zero if the conversion is
 *     succcesful, else zero.
 *
 *     Write the floating point number to *pVal. Write the number of bytes
 *     convereted to *pLen.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static int tokenToReal(pToken, pLen, pVal)
    CssToken *pToken;
    int *pLen;
    double *pVal;
{
    char zBuf[100];
    char *zEnd;
    if (pToken->n>99) {
        return 0;
    }
    strncpy(zBuf, pToken->z, pToken->n);
    zBuf[pToken->n] = '\0';
    *pVal = strtod(zBuf, &zEnd);
    if (zEnd!=zBuf) {
        *pLen = (zEnd-zBuf);
        return 1;
    }
    return 0;
}

/*
 *---------------------------------------------------------------------------
 *
 * rgbToColor --
 *
 *     This function is invoked when a property value of the form 
 *     "rgb(rrr, ggg, bbb)" is encountered. This routine interprets the
 *     property and transforms it to a string of the form #AAAAAA which can
 *     be understood as a color by Tk.
 *
 *     The first argument, zOut, points to a buffer of not less than 8
 *     bytes. The output string and it's NULL terminator is written here.
 *     The second parameter, zRgb, points to the first byte past the '('
 *     character of the original property value. The final parameter, nRgb,
 *     is the number of bytes between the '(' and ')' character of the
 *     original property.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     Writes exactly 8 bytes to zOut.
 *
 *---------------------------------------------------------------------------
 */
static void 
rgbToColor(zOut, zRgb, nRgb)
    char *zOut;
    CONST char *zRgb;
    int nRgb;
{
    CONST char *z = zRgb;
    CONST char *zEnd = zRgb+nRgb;
    int n = 0;
    int aN[3] = {0, 0, 0};

    while (z < zEnd && n < 3) {
        while (!isdigit(*z) && *z!='.' && *z!='-' && *z!='+') z++;
        aN[n] = (int)strtod(z, (char **)&z);
        if (*z=='%') {
            aN[n] = ((aN[n] * 255) / 100);
        }
        aN[n] = MIN(aN[n], 255);
        aN[n] = MAX(aN[n], 0);
        n++;
    }

    n = sprintf(zOut, "#%.2x%.2x%.2x", aN[0], aN[1], aN[2]);
    assert(n==7);
}

/*
 *---------------------------------------------------------------------------
 *
 * tokenToProperty --
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static CssProperty *
tokenToProperty(pToken)
    CssToken *pToken;
{
    struct LengthFormat {
        int type;
        int len;
        char *zUnit;
        int integer;
    } lengths[] = {
        {CSS_TYPE_EM,         2, "em", 0},
        {CSS_TYPE_EX,         2, "ex", 0},
        {CSS_TYPE_PX,         2, "px", 1},
        {CSS_TYPE_PT,         2, "pt", 1},
        {CSS_TYPE_PERCENT,    1, "%", 1},
        {CSS_TYPE_FLOAT,      0, "", 0},
        {CSS_TYPE_CENTIMETER, 2, "cm", 0},
        {CSS_TYPE_MILLIMETER, 2, "mm", 0},
        {CSS_TYPE_INCH,       2, "in", 0},
        {CSS_TYPE_PC,         2, "pc", 0},
    };

    struct FunctionFormat {
        int type;
        int len;
        char *zFunc;
    } functions[] = {
        {CSS_TYPE_TCL, 3, "tcl"},
        {CSS_TYPE_URL, 3, "url"},
        {-1,           3, "rgb"},
    };

    CssProperty *pProp = 0;
    int i;
    double realval;       /* Real value, if token can be converted to float */
    int reallen;          /* Bytes of token converted to realval */

    CONST char *z = pToken->z;
    int n = pToken->n;

    /* Check if this is a length. It is a length if the token consists
     * of a floating point number followed by one of the units enumerated
     * above in the array of LengthFormat structs.
     */
    if (tokenToReal(pToken, &reallen, &realval)) {
        for (i=0; i<(sizeof(lengths)/sizeof(lengths[0])); i++) {
            CONST char *zTokenUnit = &z[reallen];
            if ((n-reallen)==lengths[i].len &&
                    0==strncmp(zTokenUnit, lengths[i].zUnit, lengths[i].len)) {
                pProp = (CssProperty *)ckalloc(sizeof(CssProperty));
                pProp->eType = lengths[i].type;
                if (lengths[i].integer) {
                    pProp->v.iVal = (int)realval;
                } else {
                    pProp->v.rVal = realval;
                }
                break;
            }
        }
    }

    /* Check if this is a function call. A function call is anything that
     * begins with one or more alphabetic characters and a '(' character.
     * The last character of the token must be ')'.
     */
    if (z[n-1]==')') {
        for (i=0; i<n && isalpha((int)z[i]); i++);
        if (i<n && i>0 && z[i]=='(') {
            int l = i;
            int nFunc = sizeof(functions)/sizeof(struct FunctionFormat);
            for (i=0; pProp==0 && i<nFunc; i++) {
                if (l==functions[i].len && 0==strncmp(functions[i].zFunc,z,l)) {
                    char CONST *zArg;
                    int nArg;

                    zArg = &z[l+1];
                    nArg = (n-l-2); /* len(token)-len(func)-len('(')-len(')') */

                    if (functions[i].type==-1) {
                        /* -1 means this is an RGB value. Transform to a
                         * color string that Tcl can understand before
			 * storing it in the properties database. The color
			 * string will be 7 characters long exactly.
                         */
                        int nAlloc = sizeof(CssProperty) + 7 + 1;
                        pProp = (CssProperty *)ckalloc(nAlloc);
                        pProp->eType = CSS_TYPE_STRING;
                        pProp->v.zVal = (char *)&pProp[1];
                        rgbToColor(pProp->v.zVal, zArg, nArg);
                    } else {
                        int nAlloc = sizeof(CssProperty) + nArg + 1;
                        pProp = (CssProperty *)ckalloc(nAlloc);
                        pProp->eType = functions[i].type;
                        pProp->v.zVal = (char *)&pProp[1];
                        strncpy(pProp->v.zVal, zArg, nArg);
                        pProp->v.zVal[nArg] = '\0';
                    }

                    /* TODO: Dequote? */
                    break;
                }
            }
        }
    }

    /* Finally, treat the property as a generic string. v.zVal will point at
     * a NULL-terminated copy of the string. The eType field is set to
     * either CSS_TYPE_STRING, or one of the symbols in cssprop.h (i.e.
     * CSS_TYPE_BLOCK).
     */
    if (!pProp) {
        int eType;
        pProp = (CssProperty *)ckalloc(sizeof(CssProperty)+(n+1));
        pProp->v.zVal = (char *)&pProp[1];
        memcpy(pProp->v.zVal, z, n);
        pProp->v.zVal[n] = '\0';

        eType = HtmlCssStringToConstant(pProp->v.zVal);
        pProp->eType = eType > 0 ? eType : CSS_TYPE_STRING;

        /* TODO: Dequote? */
    }
    return pProp;
}

/*
 *---------------------------------------------------------------------------
 *
 * HtmlCssStringToProperty --
 *
 *     This is an externally available interface to convert the property
 *     value string pointed to by z, length n, to a property object. The
 *     caller should call ckfree() on the return value when it has finished
 *     with it.
 *
 * Results:
 *     Allocated CssProperty object.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
CssProperty *HtmlCssStringToProperty(z, n)
    CONST char *z; 
    int n;
{
    CssToken sToken;
    if (n<0) {
        n = strlen(z);
    }
    sToken.z = z;
    sToken.n = n;
    return tokenToProperty(&sToken);
}

/*
 *---------------------------------------------------------------------------
 *
 * HtmlCssPropertyGetString --
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
CONST char *
HtmlCssPropertyGetString(pProp)
    CssProperty *pProp;
{
    if (pProp) {
        int eType = pProp->eType;
        if (eType == CSS_TYPE_STRING || 
            (eType >= CSS_CONST_MIN_CONSTANT && eType <= CSS_CONST_MAX_CONSTANT)
        ) {
            return pProp->v.zVal;
        }
    }
    return 0;
}

/*--------------------------------------------------------------------------
 *
 * propertySetNew --
 *
 *     Allocate a new (empty) property set. The caller should eventually
 *     delete the property set using propertySetFree().
 *
 * Results:
 *     An empty property set.
 *
 * Side effects:
 *     None.
 *
 *--------------------------------------------------------------------------
 */
static CssPropertySet *
propertySetNew(){
    CssPropertySet *p = (CssPropertySet *)ckalloc(sizeof(CssPropertySet));
    if( p ){
        memset(p, 0, sizeof(CssPropertySet));
    }
    return p;
}

/*--------------------------------------------------------------------------
 *
 * propertySetGet --
 *
 *     Retrieve CSS property 'i' if present in the property-set. 
 *
 * Results:
 *
 *     Return NULL if the property is not present, or a pointer to the
 *     value if it is.
 *
 * Side effects:
 *     None.
 *
 *--------------------------------------------------------------------------
 */
static CssProperty *
propertySetGet(p, i)
    CssPropertySet *p;         /* Property set */
    int i;                     /* Property id (i.e CSS_PROPERTY_WIDTH) */
{
    int j;
    assert( i<128 && i>=0 );

    for (j = 0; j < p->n; j++) {
        if (i == p->a[j].eProp) {
            return p->a[j].pProp;
        }
    }

    return 0;
}

/*--------------------------------------------------------------------------
 *
 * propertySetAdd --
 *
 *     Insert or replace a value into a property set.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *--------------------------------------------------------------------------
 */
static void 
propertySetAdd(p, i, v)
    CssPropertySet *p;         /* Property set. */
    int i;                     /* Property id (i.e CSS_PROPERTY_WIDTH). */
    CssProperty *v;            /* Value for property. */
{
    int j;
    int nBytes;

    assert( i<128 && i>=0 );

    for (j = 0; j < p->n; j++) {
        if (i == p->a[j].eProp) {
            ckfree((char *)p->a[j].pProp);
            p->a[j].pProp = v;
            return;
        }
    }

    nBytes = (p->n + 1) * sizeof(struct CssPropertySetItem);
    p->a = (struct CssPropertySetItem *)ckrealloc((char *)p->a, nBytes);
    p->a[p->n].pProp = v;
    p->a[p->n].eProp = i;
    p->n++;
}

/*--------------------------------------------------------------------------
 *
 * propertySetFree --
 *
 *     Delete a property set and it's contents.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *--------------------------------------------------------------------------
 */
static void 
propertySetFree(CssPropertySet *p){
    int i;
    if( !p ) return;
    for (i = 0; i < p->n; i++) {
        ckfree((char *)p->a[i].pProp);
    }
    ckfree((char *)p->a);
    ckfree((char *)p);
}

/*
 *---------------------------------------------------------------------------
 *
 * propertyDup --
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static CssProperty *propertyDup(pProp)
    CssProperty *pProp;
{
    CssProperty *pRet = (CssProperty *)ckalloc(sizeof(CssProperty));
    memcpy(pRet, pProp, sizeof(CssProperty));
    return pRet;
}

/*
 *---------------------------------------------------------------------------
 *
 * propertyIsLength --
 *
 *     Return true if the property passed as the first argument is a length
 *     property. (i.e. pixels, em, percentage etc.)
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static int propertyIsLength(pProp)
    CssProperty *pProp;
{
    return (
        pProp->eType==CSS_TYPE_EM ||
        pProp->eType==CSS_TYPE_PT ||
        pProp->eType==CSS_TYPE_PC ||
        pProp->eType==CSS_TYPE_EX ||
        pProp->eType==CSS_TYPE_PX ||
        pProp->eType==CSS_TYPE_PERCENT
    );
}

/*
 *---------------------------------------------------------------------------
 *
 * getNextListItem --
 *
 *     Return the first property from a space seperated list of properties.
 *
 *     The property list is stored in string zList, length nList.
 *
 *     A pointer to the first property is returned. The length of the first
 *     property is stored in *pN.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static CONST char *getNextListItem(zList, nList, pN)
    CONST char *zList;
    int nList;
    int *pN;
{
    int n = 0;
    int t = CT_SPACE;
    CONST char *zRet = 0;
    CONST char *z = zList;
    CONST char *zEnd = zList+nList;

    while (z<zEnd && t==CT_SPACE) {
        t = cssGetToken(z, zEnd-z, &n);
        assert(n>0);
        if (t==CT_SPACE) {
            z += n;
        }
    }
    zRet = z;
    z += n;

    while (z<zEnd && t!=CT_SPACE) {
        int n2 = 0;
        t = cssGetToken(z, zEnd-z, &n2);
        assert(n2>0);
        z += n2;
        if (t!=CT_SPACE) {
            n += n2;
        }
    }

    if (zRet<zEnd && n>0) {
        assert(n<=nList);
        *pN = n;
        return zRet;
    }
    return 0;
}

/*
 *---------------------------------------------------------------------------
 *
 * propertySetAddShortcutBorder --
 *
 *     Devolve the shortcut property 'border' into it's sub-properties and
 *     add the results to a CssPropertySet.
 *
 *     A 'border' property consists of a white-space seperated list of at
 *     most three quantities. Any of the three quantities may be omitted,
 *     but the order remains the same.
 *
 *     [<border-width>] [<border-style>] [<border-color>]
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static void propertySetAddShortcutBorder(p, prop, v)
    CssPropertySet *p;         /* Property set. */
    int prop;
    CssToken *v;               /* Value for property. */
{
    CONST char *z = v->z;
    CONST char *zEnd = z + v->n;
    int n;

    int aWidth[] = {
        CSS_PROPERTY_BORDER_TOP_WIDTH,
        CSS_PROPERTY_BORDER_RIGHT_WIDTH,
        CSS_PROPERTY_BORDER_BOTTOM_WIDTH,
        CSS_PROPERTY_BORDER_LEFT_WIDTH,
    };
    int aStyle[] = {
        CSS_PROPERTY_BORDER_TOP_STYLE,
        CSS_PROPERTY_BORDER_RIGHT_STYLE,
        CSS_PROPERTY_BORDER_BOTTOM_STYLE,
        CSS_PROPERTY_BORDER_LEFT_STYLE,
    };
    int aColor[] = {
        CSS_PROPERTY_BORDER_TOP_COLOR,
        CSS_PROPERTY_BORDER_RIGHT_COLOR,
        CSS_PROPERTY_BORDER_BOTTOM_COLOR,
        CSS_PROPERTY_BORDER_LEFT_COLOR,
    };

    int iOffset = 0;        /* Offset in aWidth[], aStyle[], aColor[] */
    int nProp = 1;          /* Number of properties to set */
    switch (prop) {
        case CSS_SHORTCUTPROPERTY_BORDER:
            nProp = 4;
            break;
        case CSS_SHORTCUTPROPERTY_BORDER_TOP:
            break;
        case CSS_SHORTCUTPROPERTY_BORDER_RIGHT:
            iOffset = 1;
            break;
        case CSS_SHORTCUTPROPERTY_BORDER_BOTTOM:
            iOffset = 2;
            break;
        case CSS_SHORTCUTPROPERTY_BORDER_LEFT:
            iOffset = 3;
            break;
        default:
            assert(0);
    }

    while (z) {
        z = getNextListItem(z, zEnd-z, &n);
        if (z) {
            int *aProp = 0;
            CssToken token;
            CssProperty *pProp;
            int i;
            int eType;

            token.z = z;
            token.n = n;
            pProp = tokenToProperty(&token);
            eType = pProp->eType;

            if (propertyIsLength(pProp) || eType==CSS_TYPE_FLOAT) {
                aProp = aWidth;
            } else if (
                eType == CSS_CONST_NONE   || eType == CSS_CONST_HIDDEN ||
                eType == CSS_CONST_DOTTED || eType == CSS_CONST_DASHED ||
                eType == CSS_CONST_SOLID  || eType == CSS_CONST_DOUBLE ||
                eType == CSS_CONST_GROOVE || eType == CSS_CONST_RIDGE  ||
                eType == CSS_CONST_OUTSET || eType == CSS_CONST_INSET 
            ) {
                aProp = aStyle;
            } else if (
                eType == CSS_CONST_THIN || eType == CSS_CONST_THICK ||
                eType == CSS_CONST_MEDIUM
            ) {
                aProp = aWidth;
            } else {
                aProp = aColor;
            }

            for (i = iOffset; i < iOffset+nProp; i++) {
                if (i != iOffset) {
                    pProp = propertyDup(pProp);
                }
                propertySetAdd(p, aProp[i], pProp);
            }
            
            assert(n>0);
            z += n;
        }
    }
}


/*
 *---------------------------------------------------------------------------
 *
 * propertySetAddShortcutBackground --
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static void 
propertySetAddShortcutBackground(p, v)
    CssPropertySet *p;         /* Property set */
    CssToken *v;               /* Value for 'background' property */
{
    CONST char *z= v->z;
    CONST char *zEnd = z + v->n;
    int n;

    while (z) {
        CssProperty *pProp;
        z = getNextListItem(z, zEnd-z, &n);
        if (z) {
            int eProp = 0;
            CssToken token;

            token.z = z;
            token.n = n;
            pProp = tokenToProperty(&token);
            z += n;

            if (propertyIsLength(pProp)) {
                eProp = CSS_PROPERTY_BACKGROUND_POSITION;
            } else {
                switch (pProp->eType) {
                    case CSS_CONST_SCROLL:
                    case CSS_CONST_FIXED:
                        eProp = CSS_PROPERTY_BACKGROUND_ATTACHMENT;
                        break;
                    case CSS_CONST_REPEAT:
                    case CSS_CONST_NO_REPEAT:
                    case CSS_CONST_REPEAT_X:
                    case CSS_CONST_REPEAT_Y:
                        eProp = CSS_PROPERTY_BACKGROUND_REPEAT;
                        break;
                    case CSS_CONST_TOP:
                    case CSS_CONST_BOTTOM:
                    case CSS_CONST_LEFT:
                    case CSS_CONST_RIGHT:
                    case CSS_CONST_CENTER:
                    case CSS_TYPE_FLOAT:
                        eProp = CSS_PROPERTY_BACKGROUND_POSITION;
                        break;
                    case CSS_TYPE_URL:
                        eProp = CSS_PROPERTY_BACKGROUND_IMAGE;
                        break;
                    default:
                        eProp = CSS_PROPERTY_BACKGROUND_COLOR;
                }
            }
            propertySetAdd(p, eProp, pProp);
        }
    }
}

/*
 *---------------------------------------------------------------------------
 *
 * propertySetAddShortcutBorderColor --
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static void propertySetAddShortcutBorderColor(p, prop, v)
    CssPropertySet *p;         /* Property set. */
    int prop;
    CssToken *v;               /* Value for property. */
{
    CONST char *z= v->z;
    CONST char *zEnd = z + v->n;
    int n;

    int i = 0;                 /* Index of apProp to read next color in to */
    CssProperty *apProp[4];    /* Array of color properties */
    memset(apProp, 0, sizeof(CssProperty *)*4);

    while (z && i<4) {
        z = getNextListItem(z, zEnd-z, &n);
        if (z) {
            CssToken token;
            token.z = z;
            token.n = n;
            apProp[i] = tokenToProperty(&token);
            i++;
            assert(n>0);
            z += n;
        }
    }

    switch (i) {
        case 1:
            apProp[1] = propertyDup(apProp[0]);
            apProp[2] = propertyDup(apProp[0]);
            apProp[3] = propertyDup(apProp[0]);
            break;
        case 2:
            apProp[2] = propertyDup(apProp[0]);
            apProp[3] = propertyDup(apProp[1]);
            break;
        case 3:
            apProp[3] = propertyDup(apProp[1]);
            break;
        case 4:
            break;
        default:
            return;
    }

    switch (prop) {
        case CSS_SHORTCUTPROPERTY_BORDER_COLOR:
            propertySetAdd(p, CSS_PROPERTY_BORDER_TOP_COLOR, apProp[0]);
            propertySetAdd(p, CSS_PROPERTY_BORDER_RIGHT_COLOR, apProp[1]);
            propertySetAdd(p, CSS_PROPERTY_BORDER_BOTTOM_COLOR, apProp[2]);
            propertySetAdd(p, CSS_PROPERTY_BORDER_LEFT_COLOR, apProp[3]);
            break;
        case CSS_SHORTCUTPROPERTY_BORDER_STYLE:
            propertySetAdd(p, CSS_PROPERTY_BORDER_TOP_STYLE, apProp[0]);
            propertySetAdd(p, CSS_PROPERTY_BORDER_RIGHT_STYLE, apProp[1]);
            propertySetAdd(p, CSS_PROPERTY_BORDER_BOTTOM_STYLE, apProp[2]);
            propertySetAdd(p, CSS_PROPERTY_BORDER_LEFT_STYLE, apProp[3]);
            break;
        case CSS_SHORTCUTPROPERTY_BORDER_WIDTH:
            propertySetAdd(p, CSS_PROPERTY_BORDER_TOP_WIDTH, apProp[0]);
            propertySetAdd(p, CSS_PROPERTY_BORDER_RIGHT_WIDTH, apProp[1]);
            propertySetAdd(p, CSS_PROPERTY_BORDER_BOTTOM_WIDTH, apProp[2]);
            propertySetAdd(p, CSS_PROPERTY_BORDER_LEFT_WIDTH, apProp[3]);
            break;
        case CSS_SHORTCUTPROPERTY_PADDING:
            propertySetAdd(p, CSS_PROPERTY_PADDING_TOP, apProp[0]);
            propertySetAdd(p, CSS_PROPERTY_PADDING_RIGHT, apProp[1]);
            propertySetAdd(p, CSS_PROPERTY_PADDING_BOTTOM, apProp[2]);
            propertySetAdd(p, CSS_PROPERTY_PADDING_LEFT, apProp[3]);
            break;
        case CSS_SHORTCUTPROPERTY_MARGIN:
            propertySetAdd(p, CSS_PROPERTY_MARGIN_TOP, apProp[0]);
            propertySetAdd(p, CSS_PROPERTY_MARGIN_RIGHT, apProp[1]);
            propertySetAdd(p, CSS_PROPERTY_MARGIN_BOTTOM, apProp[2]);
            propertySetAdd(p, CSS_PROPERTY_MARGIN_LEFT, apProp[3]);
            break;
    }
}

/*--------------------------------------------------------------------------
 *
 * selectorFree --
 *
 *     Delete a linked list of CssSelector structs, including the 
 *     CssSelector.zValue and CssSelector.zAttr fields.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *--------------------------------------------------------------------------
 */
static void selectorFree(pSelector)
    CssSelector *pSelector;
{
    if( !pSelector ) return;
    selectorFree(pSelector->pNext);
    ckfree(pSelector->zValue);
    ckfree(pSelector->zAttr);
    ckfree((char *)pSelector);
}

/*
 *---------------------------------------------------------------------------
 *
 * cssGetToken --
 *
 *     Return the id of the next CSS token in the string pointed to by z,
 *     length n. The length of the token is written to *pLen. 0 is returned
 *     if there are no complete tokens remaining.
 *
 * Results:
 *     See above.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static int 
cssGetToken(z, n, pLen)
    CONST char *z; 
    int n; 
    int *pLen;
{
    if( n<=0 ){
      return 0;
    }

    *pLen = 1;
    switch( z[0] ){
        case ' ':
        case '\n':
        case '\t': return CT_SPACE;
        case '{':  return CT_LP;
        case '}':  return CT_RP;
        case ')':  return CT_RRP;
        case '[':  return CT_LSP;
        case ']':  return CT_RSP;
        case ';':  return CT_SEMICOLON;
        case ',':  return CT_COMMA;
        case ':':  return CT_COLON;
        case '+':  return CT_PLUS;
        case '>':  return CT_GT;
        case '*':  return CT_STAR;
        case '.':  return CT_DOT;
        case '#':  return CT_HASH;
        case '=':  return CT_EQUALS;
        case '~':  return CT_TILDE;
        case '|':  return CT_PIPE;
        case '/':  {
            int i;
            int c;
            if( z[1]!='*' || z[2]==0 ){
                return CT_SLASH;
            }
            for(i=3, c=z[2]; (c!='*' || z[i]!='/') && (c=z[i])!=0; i++){}
            if( c ) i++;
            *pLen = i;
            return -1;
        }

        case '"': case '\'': {
            char delim = z[0];
            char c;
            int i;
            for(i=1; i<n; i++){
                c = z[i];
                if( c=='\\' ){
                    i++;
                }
                if( c==delim ){
                    *pLen = i+1; 
                    return CT_STRING;
                }
            }
            *pLen = n;
            return -1;
        }

        case '@': {
            struct AtKeyWord {
                const char *z;
                int n;
                int t;
            } atkeywords[] = {
                {"import", 6, CT_IMPORT_SYM},
                {"page", 4, CT_PAGE_SYM},
                {"media", 5, CT_MEDIA_SYM},
                {"font-face", 9, CT_FONT_SYM},
                {"charset", 7, CT_CHARSET_SYM},
            };
            int i;
            for(i=0; i<sizeof(atkeywords)/sizeof(struct AtKeyWord); i++){
                if( 0==strncmp(&z[1], atkeywords[i].z, atkeywords[i].n) ){
                    *pLen = atkeywords[i].n + 1;
                    return atkeywords[i].t;
                }
            }
            goto bad_token;
        }
        case '!': {
            if( 0==strncmp(&z[1], "important", 9) ){
                 *pLen = 9 + 1;
                 return CT_IMPORTANT_SYM;
            }
            goto bad_token;
        }

        default: {
            /* This must be either an identifier or a function. For the
            ** ASCII character range 0-127, the 'charmap' array is 1 for
            ** characters allowed in an identifier or function name, 0
            ** for characters not allowed. Allowed characters are a-z, 
	    ** 0-9, '-', '_', '%' and '\'. All unicode characters
            ** outside the ASCII range are allowed.
            */
            static u8 charmap[128] = {
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0x00-0x0F */
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0x10-0x1F */
                0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, /* 0x20-0x2F */
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, /* 0x30-0x3F */
                0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* 0x40-0x4F */
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, /* 0x50-0x5F */
                0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* 0x60-0x6F */
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0  /* 0x70-0x7F */
            };
            int i;
            for(i=0; i<n && (z[i]<0 || charmap[(int)z[i]]); i++) /* empty */ ;
            if( i==0 ) goto bad_token;
            if( i<n && z[i]=='(' ){
                int t = -1;
                int tlen;
                i++;
                while( i!=n && t!=0 && t!=CT_RRP ){
                    t = cssGetToken(&z[i], n-i, &tlen);
                    i += tlen;
                }
                if( t!=CT_RRP ) goto bad_token;
                *pLen = i;
                return CT_FUNCTION;
            }
            *pLen = i;
            return CT_IDENT;
        }
             
    }

bad_token:
    *pLen = 1;
    return -1;
}

/* Versions of ckalloc() and ckfree() that are always functions (not macros). 
*/
static void * xCkalloc(size_t n){
    return ckalloc(n);
}
static void xCkfree(void *p){
    ckfree(p);
}


/*
 *---------------------------------------------------------------------------
 *
 * comparePriority --
 *
 *     Compare stylesheet priorities *pLeft and *pRight, returning less
 *     than, equal to or greater than zero if *pLeft is less than, equal
 *     to, or greater than pRight. i.e the expression:
 *
 *         (*pLeft - *pRight)
 *
 *     Note that this comparison follows the rules of CSS2, not CSS1.
 *
 * Results:
 *     Result of comparison (see above).
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static int 
comparePriority(pLeft, pRight)
    CssPriority *pLeft;
    CssPriority *pRight;
{
    int aNormal[3] = {CSS_ORIGIN_AUTHOR, CSS_ORIGIN_USER, CSS_ORIGIN_AGENT};
    int aImportant[3] = {CSS_ORIGIN_USER, CSS_ORIGIN_AUTHOR, CSS_ORIGIN_AGENT};
    int *a = 0;

    if (pLeft->important && pRight->important) {
        a = aImportant;
    }
    if (!pLeft->important && !pRight->important) {
        a = aNormal;
    }

    /* If a is set then the 'important' flags are both set or both cleared.
     * This means we have to look at the origin (and possibly style-id)
     * values.
     */
    if (a) { 
        int i;
        if (pLeft->origin == pRight->origin) {
            CONST char *zLeft = Tcl_GetString(pLeft->pIdTail);
            CONST char *zRight = Tcl_GetString(pRight->pIdTail);
            return strcmp(zLeft, zRight);
        }
        for (i = 0; i < 3; i++) {
            if (pLeft->origin == a[i]) return 1;
            if (pRight->origin == a[i]) return -1;
        }
        assert(!"Impossible");
    }

    /* One 'important' flag is set and the other cleared. The highest
     * priority is therefore the one with the 'important' flag set.
     */
    return pLeft->important ? 1 : -1;
}

/*
 *---------------------------------------------------------------------------
 *
 * newCssPriority --
 *
 *     Add a new entry to the CssStyleSheet.pPriority list with values
 *     origin, pIdTail and important. Update the CssPriority.iPriority
 *     variable for all list members that require it.
 *
 *     See comments above CssPriority struct in cssInt.h for details.
 *
 *     The pointer to pIdList is copied and the reference count increased
 *     by one. It is decreased when the new list entry is deleted (along
 *     with the rest of the stylesheet).
 *
 * Results:
 *     Pointer to new list entry.
 *
 * Side effects:
 *     Modifies linked-list pStyle->pPriority. 
 *
 *---------------------------------------------------------------------------
 */
static CssPriority * 
newCssPriority(pStyle, origin, pIdTail, important)
    CssStyleSheet *pStyle;
    int origin;
    Tcl_Obj *pIdTail;
    int important;
{
    CssPriority *pNew;      /* New list entry */
    CssPriority *pPrev = 0; /* Entry just before the new one in the list */
    CssPriority *pIter;

    pNew = (CssPriority *)ckalloc(sizeof(CssPriority));
    pNew->origin = origin;
    pNew->important = important;
    pNew->pIdTail = pIdTail;
    Tcl_IncrRefCount(pIdTail);

    /* Set pPrev to the entry in the list that will come just before the
     * new entry, or to NULL if the new entry is the highest priority seen
     * so far.
     */
    for (
        pIter = pStyle->pPriority; 
        pIter && comparePriority(pIter, pNew) > 0;
        pIter = pIter->pNext
    ) {
        pPrev = pIter;
    }
   
    if (!pPrev) {
        pNew->iPriority = 0;
        pNew->pNext = pStyle->pPriority;
        pStyle->pPriority = pNew;
    } else {
        pNew->iPriority = pPrev->iPriority;
        pNew->pNext = pPrev->pNext;
        pPrev->pNext = pNew;
    }

    for (pIter = pNew; pIter; pIter = pIter->pNext) {
	pIter->iPriority++;
    }

#ifndef NDEBUG
    /* Check the list insertion code above worked (i.e. the list is still in
     * priority order with the correct iPriority values). 
     */
    for (pIter = pNew; pIter && pIter->pNext; pIter = pIter->pNext) {
	assert((pIter->iPriority + 1) == pIter->pNext->iPriority);
        assert(comparePriority(pIter, pIter->pNext) >= 0);
    }
#endif

    return pNew;
}

/*
 *---------------------------------------------------------------------------
 *
 * cssParse --
 *
 *     This routine does the work of parsing stylesheets or style
 *     attributes on behalf of HtmlCssParse() and HtmlCssParseStyle()
 *     respectively. 
 * 
 *     The first two argument identify the length of, and the text to be
 *     parsed.
 *
 *     The third argument is true if z points to the text of a style
 *     attribute, i.e: "color:red ; margin:0.4em". If false, then z points
 *     to an stylesheet, i.e. "H1 {text-size: 1.2em}". The stylesheet
 *     produced when parsing a style is the same as "* {<style text>}".
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static int 
cssParse(n, z, isStyle, origin, pStyleId, ppStyle)
    int n;                       /* Size of z in bytes */
    CONST char *z;               /* Text of attribute/document */
    int isStyle;                 /* True if this is a style attribute */
    int origin;                  /* CSS_ORIGIN_* value */
    Tcl_Obj *pStyleId;           /* Second and later parts of stylesheet id */
    CssStyleSheet **ppStyle;     /* IN/OUT: Stylesheet to append to   */
{
    CssParse sParse;
    CssToken sToken;
    void *p;
    int t;
    int c = 0;

    memset(&sParse, 0, sizeof(CssParse));
    sParse.origin = origin;
    sParse.pStyleId = pStyleId;

    if( n<0 ){
        n = strlen(z);
    }
    p = tkhtmlCssParserAlloc(xCkalloc);

    /* If *ppStyle is NULL, then create a new CssStyleSheet object. If it
     * is not zero, then append the rules from the new stylesheet document
     * to the existing object.
     */
    if (0==*ppStyle) {
        sParse.pStyle = (CssStyleSheet *)ckalloc(sizeof(CssStyleSheet));
        memset(sParse.pStyle, 0, sizeof(CssStyleSheet));
    } else {
        sParse.pStyle = *ppStyle;
    }

    /* If this is a stylesheet, not a style attribute, add the priority
     * entries for both regular and "!important" properties for this
     * stylesheet to the priority list.
     */
    if (!isStyle) {
        sParse.pPriority1 = newCssPriority(sParse.pStyle, origin, pStyleId, 0);
        sParse.pPriority2 = newCssPriority(sParse.pStyle, origin, pStyleId, 1);
    }

    /* If this is a style attribute, not a stylesheet, then feed the
     * parser the tokens '*' and '{' before attempting to parse the style
     * attribute text. After parsing the text, feed the parser a '}' to
     * finish everything off. Thus a style is converted to a stylesheet
     * with a rule, using the universal selector.
     */
    if (isStyle) {
         sToken.z = "*"; sToken.n = 1; 
         tkhtmlCssParser(p, CT_STAR, sToken, &sParse);
         sToken.z = "{"; sToken.n = 1; 
         tkhtmlCssParser(p, CT_LP, sToken, &sParse);
    }

    while( (t=cssGetToken(&z[c], n-c, &sToken.n)) ){
        sToken.z = &z[c];
        if( t>0 && t!=CT_IMPORTANT_SYM ){
            tkhtmlCssParser(p, t, sToken, &sParse);
        }
        c += sToken.n;
    }

    /* if this is a style, not a stylesheet (see above), then feed the
     * closing '}' token to the parser.
     */
    if (isStyle) {
         sToken.z = "}"; sToken.n = 1; 
         tkhtmlCssParser(p, CT_RP, sToken, &sParse);

         /* Todo: The parser seems to need one more token to work... */
         sToken.z = " "; sToken.n = 1; 
         tkhtmlCssParser(p, CT_SPACE, sToken, &sParse);
    }

    *ppStyle = sParse.pStyle;
    tkhtmlCssParserFree(p, xCkfree);

    return 0;
}

/*--------------------------------------------------------------------------
 *
 * HtmlCssParse --
 *
 *     Parse the stylesheet pointed to by z, length n bytes. See comments
 *     above cssParse() for more detail.
 *
 * Results:
 *
 *     Returns a CssStyleSheet pointer, written to *ppStyle.
 *
 * Side effects:
 *
 *--------------------------------------------------------------------------
 */
int 
HtmlCssParse(pText, origin, pStyleId, ppStyle)
    Tcl_Obj *pText;
    int origin;
    Tcl_Obj *pStyleId;
    CssStyleSheet **ppStyle;
{
    int n;
    CONST char *z;
    z = Tcl_GetStringFromObj(pText, &n);
    return cssParse(n, z, 0, origin, pStyleId, ppStyle);
}

/*--------------------------------------------------------------------------
 *
 * HtmlCssParseStyle --
 *
 *     Parse the style attribute value pointed to by z, length n bytes. See
 *     comments above cssParse() for more detail.
 *
 * Results:
 *
 *     Returns a CssStyleSheet pointer, written to *ppStyle.
 *
 * Side effects:
 *
 *--------------------------------------------------------------------------
 */
int HtmlCssParseStyle(
    int n,
    const char *z,
    CssProperties **ppProperties
){
    CssStyleSheet *pStyle = 0;
    assert(ppProperties && !(*ppProperties));
    cssParse(n, z, 1, 0, 0, &pStyle);
    if (pStyle) {
        if (pStyle->pUniversalRules) {
            assert(!pStyle->pUniversalRules->pNext);
            propertiesAdd(ppProperties, pStyle->pUniversalRules);
            pStyle->pUniversalRules = 0;
        }
        assert(!pStyle->pPriority);
        HtmlCssStyleSheetFree(pStyle);
    }
    return 0;
}

/*
 *---------------------------------------------------------------------------
 *
 * ruleFree --
 *
 *     Free the CssRule object pRule.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static void ruleFree(pRule)
    CssRule *pRule;
{
    if (pRule) {
        selectorFree(pRule->pSelector);
        if (pRule->freePropertySets) {
            propertySetFree(pRule->pPropertySet);
        }
        ckfree((char *)pRule);
    }
}

/*
 *---------------------------------------------------------------------------
 *
 * HtmlCssStyleSheetFree --
 *
 *     Delete the internal representation of the stylesheet configuration.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
void 
HtmlCssStyleSheetFree(pStyle)
    CssStyleSheet *pStyle;
{
    if (pStyle) {
        CssPriority *pPriority;
        CssRule *pRule;

        pRule = pStyle->pUniversalRules; 
        while (pRule) { 
            CssRule *pNext = pRule->pNext;
            ruleFree(pRule);
            pRule = pNext;
        }

        pPriority = pStyle->pPriority;
        while (pPriority) {
            CssPriority *pNext = pPriority->pNext;
            Tcl_DecrRefCount(pPriority->pIdTail);
            ckfree((char *)pPriority);
            pPriority = pNext;
        }

        ckfree((char *)pStyle);
    }
}

/*
** Return the number of syntax errors that occured while parsing the
** style-sheet.
*/
int HtmlCssStyleSheetSyntaxErrs(CssStyleSheet *pStyle){
    return pStyle->nSyntaxErr;
}

/*--------------------------------------------------------------------------
 *
 * HtmlCssDeclaration --
 *
 *     This function is called by the CSS parser when it parses a property 
 *     declaration (i.e "<property> : <expression>").
 *
 * Results:
 *     None.
 *
 * Side effects:
 *
 *--------------------------------------------------------------------------
 */
void HtmlCssDeclaration(CssParse *pParse, CssToken *pProp, CssToken *pExpr){
    int prop; 
    char zBuf[64];

#if TRACE_PARSER_CALLS
    printf("HtmlCssDeclaration(%p, \"%.*s\", \"%.*s\")\n", 
        pParse,
        pProp?pProp->n:0, pProp?pProp->z:"", 
        pExpr?pExpr->n:0, pExpr?pExpr->z:""
    );
#endif

    /* Resolve the property name. If we don't recognize it, then ignore
     * the entire declaration (CSS2 spec says to do this).
     */
    strncpy(zBuf, pProp->z, MIN(pProp->n, 63));
    zBuf[63] = 0;
    Tcl_UtfToLower(zBuf);
    prop = HtmlCssPropertyToString(MIN(63, pProp->n), zBuf);
    if( prop<0 ) return;
    if( !pParse->pPropertySet ){
        pParse->pPropertySet = propertySetNew();
    }

    switch (prop) {
        case CSS_SHORTCUTPROPERTY_BORDER:
        case CSS_SHORTCUTPROPERTY_BORDER_LEFT:
        case CSS_SHORTCUTPROPERTY_BORDER_RIGHT:
        case CSS_SHORTCUTPROPERTY_BORDER_TOP:
        case CSS_SHORTCUTPROPERTY_BORDER_BOTTOM:
            propertySetAddShortcutBorder(pParse->pPropertySet, prop, pExpr);
            break;
        case CSS_SHORTCUTPROPERTY_BORDER_COLOR:
        case CSS_SHORTCUTPROPERTY_BORDER_STYLE:
        case CSS_SHORTCUTPROPERTY_BORDER_WIDTH:
        case CSS_SHORTCUTPROPERTY_PADDING:
        case CSS_SHORTCUTPROPERTY_MARGIN:
            propertySetAddShortcutBorderColor(pParse->pPropertySet,prop,pExpr);
            break;
        case CSS_SHORTCUTPROPERTY_BACKGROUND:
            propertySetAddShortcutBackground(pParse->pPropertySet, pExpr);
            break;
        default:
            propertySetAdd(pParse->pPropertySet, prop, tokenToProperty(pExpr));
    }
}


static void dequote(z)
    char *z;
{
    int n;
    if (!z) return;
    n = strlen(z);
    if (z[0]=='"' && z[n-1]=='"') {
        int i;
        for (i=0; i<(n-2); i++) {
             z[i] = z[i+1];
        }
        z[n-2] = '\0';
    }
}


/*--------------------------------------------------------------------------
 *
 * HtmlCssSelector --
 *
 *     This is called whenever a simple selector is parsed. 
 *     i.e. "H1" or ":before".
 *
 * Results:
 *     None.
 *
 * Side effects:
 *
 *--------------------------------------------------------------------------
 */
void HtmlCssSelector(pParse, stype, pAttr, pValue)
    CssParse *pParse; 
    int stype; 
    CssToken *pAttr; 
    CssToken *pValue;
{
    CssSelector *pSelector;

#if TRACE_PARSER_CALLS
    /* I used this to make sure the parser was passing the components of
     * selectors to this function in the correct order. Once this was 
     * verified, it is not particularly useful trace output. But we'll leave
     * it here for the time being in case something comes up.
     */
    printf("HtmlCssSelector(%p, %s, \"%.*s\", \"%.*s\")\n", 
        pParse, constantToString(stype), 
        pAttr?pAttr->n:0, pAttr?pAttr->z:"", 
        pValue?pValue->n:0, pValue?pValue->z:""
    );
#endif

    pSelector = (CssSelector *)ckalloc(sizeof(CssSelector));
    memset(pSelector, 0, sizeof(CssSelector));
    pSelector->eSelector = stype;
    pSelector->zValue = tokenToString(pValue);
    dequote(pSelector->zValue);
    pSelector->zAttr = tokenToString(pAttr);
    pSelector->pNext = pParse->pSelector;
    pParse->pSelector = pSelector;

    /* Tag names are case-insensitive - fold to lower case */
    if( stype==CSS_SELECTOR_TYPE ){
        assert(pSelector->zValue);
        Tcl_UtfToLower(pSelector->zValue);
    }
}

/*
 *---------------------------------------------------------------------------
 *
 * ruleCompare --
 *
 *     Compare the priority of two rule objects. Return greater than zero
 *     if the priority of pLeft is higher, zero if the two rules have the
 *     same priority, and negative if pRight has higher priority. i.e.:
 *
 *         PRIORITY(pLeft) - PRIORITY(pRight)
 *
 *     This function is used to determine the order of rules in the
 *     rules CssRule.pNext linked list.
 *
 * Results:
 *     See above.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static int 
ruleCompare(CssRule *pLeft, CssRule *pRight) {
    int res = 0;

    assert(pLeft && pRight);
    assert(pRight->pPriority);
    assert(pLeft->pPriority);

    /* In this case (right - left) is correct, because iPriority is a lower
     * number for higher priority stylesheet documents. See comments above
     * CssPriority struct in cssInt.h
     */
    res = pRight->pPriority->iPriority - pLeft->pPriority->iPriority;

    if (res == 0) {
        /* But here we want (left - right), because specificity is higher
         * for more specific rules.
         */
        res = pLeft->specificity - pRight->specificity;
    }
    return res;
}

/*
 *---------------------------------------------------------------------------
 *
 * cssSelectorPropertySetPair --
 *
 *     A rule has just been parsed with selector pSelector and properties
 *     pPropertySet. This function creates a CssRule object to link the two
 *     together and inserts the new rule into the CssStyleSheet structure.
 *
 *     The caller should not free resources associated with pSelector or
 *     pPropertySet after this function returns, they are now linked into
 *     the stylesheet object.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
void 
cssSelectorPropertySetPair(pParse, pSelector, pPropertySet, freePropertySets)
    CssParse *pParse;
    CssSelector *pSelector;
    CssPropertySet *pPropertySet;
    int freePropertySets;
{
    int spec = 0;
    CssSelector *pS = 0;
    CssStyleSheet *pStyle = pParse->pStyle;
    CssRule *pRule = (CssRule *)ckalloc(sizeof(CssRule));
    memset(pRule, 0, sizeof(CssRule));

    pRule->freePropertySets = freePropertySets;

    /* Calculate the specificity of the rules. We use the following
     * formala:
     *
     *     Specificity = (number of id selectors)        * 10000 +
     *                   (number of attribute selectors) * 100   +
     *                   (number of pseudo classes)      * 100   +
     *                   (number of type selectors)
     *
     * Todo: There are (at least) two bugs here:
     *     1. A rule with 100 type selectors has greater specificity than a
     *        rule with a single attribute selector. This probably isn't a
     *        problem.
     *     2. A selector of the form '[id="hello"]' has the same
     *        specificity as the selector '.hello'. This is pretty obscure,
     *        but could come up.
     * 
     * See section 6.4, "The cascade", of CSS2 documentation for details on
     * selector specificity.
     */
    for (pS=pSelector; pS; pS = pS->pNext) {
         switch (pS->eSelector) {
             case CSS_SELECTOR_TYPE:
                 spec += 1;
                 break;
             case CSS_SELECTOR_ATTR:
             case CSS_SELECTOR_ATTRVALUE:
             case CSS_SELECTOR_ATTRLISTVALUE:
             case CSS_SELECTOR_ATTRHYPHEN:
                 if (0==strcmp(pS->zAttr, "id")) {
                     spec += 10000;
                     break;
                 }
             case CSS_PSEUDOCLASS_LANG:
             case CSS_PSEUDOCLASS_FIRSTCHILD:
             case CSS_PSEUDOCLASS_LINK:
             case CSS_PSEUDOCLASS_VISITED:
             case CSS_PSEUDOCLASS_ACTIVE:
             case CSS_PSEUDOCLASS_HOVER:
             case CSS_PSEUDOCLASS_FOCUS:
                 spec += 100;
                 break;
         }
    }
    pRule->specificity = spec;
    pRule->pPriority = pParse->pPriority1;

    if( 0 && pSelector->eSelector==CSS_SELECTOR_TYPE ){
#if 0
        Tcl_HashEntry *pEntry; 
        int n;         /* True if we add a a new hash table entry */
        assert( pSelector->zValue );
        pEntry = Tcl_CreateHashEntry(&pStyle->rules, pSelector->zValue, &n);
        pRule->pNext = Tcl_GetHashValue(pEntry);
        assert( (n && !pRule->pNext) || (!n && pRule->pNext) );
        Tcl_SetHashValue(pEntry, pRule);
#endif
    }else{
        /* The rule doesn't belong in any hash table, so put it in the
         * default list.
         */
        CssRule *pR = pStyle->pUniversalRules;

        if (!pR || ruleCompare(pR, pRule)<=0) {
            /* If the default list is currently empty, or the rule being
	     * added has higher priority than the first rule in the list,
             * our rule becomes the new head of the list.
             */
	    pRule->pNext = pStyle->pUniversalRules;
            pStyle->pUniversalRules = pRule;
        } else {
            /* Otherwise insert the new rule into the list, ordered by
             * priority. If there exists another rule with the same
             * priority, then this rule is inserted into the list *before*
             * it. This is because when rules are of equal priority, the
             * latter specified wins.
             */
            while (pR->pNext && ruleCompare(pR->pNext, pRule)>0 ) {
                pR = pR->pNext;
            }
            pRule->pNext = pR->pNext;
            pR->pNext = pRule;
        }
    }

    pRule->pSelector = pSelector;
    pRule->pPropertySet = pPropertySet;
}

int HtmlCssPseudo(pToken)
    CssToken *pToken;
{
    char *zOptions[] = {"link", "visited"};
    int eOptions[] = {CSS_PSEUDOCLASS_LINK, CSS_PSEUDOCLASS_VISITED};
    int i;

    for (i=0; i<sizeof(zOptions)/sizeof(char *); i++) {
        if (pToken->n==strlen(zOptions[i]) && 
                0==strncmp(pToken->z, zOptions[i], pToken->n)) {
            return eOptions[i];
        }
    }
    return CSS_PSEUDOCLASS_LANG;
}

/*--------------------------------------------------------------------------
 *
 * HtmlCssRule --
 *
 *     This is called when the parser has parsed an entire rule.
 *
 * Results:
 *     None.
 *
 * Side effects:
 * 
 *     If the parse was successful, then add the rule to the stylesheet.
 *     If unsuccessful, delete anything that was built up by calls to 
 *     HtmlCssDeclaration() or HtmlCssSelector().
 *
 *--------------------------------------------------------------------------
 */
void HtmlCssRule(pParse, success)
    CssParse *pParse;
    int success;
{
    CssSelector *pSelector = pParse->pSelector;
    CssPropertySet *pPropertySet = pParse->pPropertySet;
    CssSelector **apXtraSelector = pParse->apXtraSelector;
    int nXtra = pParse->nXtra;
    int i;

    pParse->pSelector = 0;
    pParse->pPropertySet = 0;
    pParse->apXtraSelector = 0;
    pParse->nXtra = 0;

    if( success && pSelector && pPropertySet ){
        cssSelectorPropertySetPair(pParse, pSelector, pPropertySet, 1);
        for (i = 0; i < nXtra; i++){
            cssSelectorPropertySetPair(pParse,apXtraSelector[i],pPropertySet,0);
        }
    }else{
        /* Some sort of a parse error has occured. We won't be including
         * this rule, so just free these structs so we don't leak memory.
         */ 
        selectorFree(pSelector);
        propertySetFree(pPropertySet);
        for (i = 0; i < nXtra; i++){
            selectorFree(apXtraSelector);
        }
    }

    if( apXtraSelector ){
        ckfree((char *)apXtraSelector);
    }
}

/*--------------------------------------------------------------------------
 *
 * attrTest --
 *
 *     Test if an attribute value matches a string. The three modes of 
 *     comparing attribute values specified in CSS are supported.
 *
 * Results:
 *     Non-zero is returned if the match is true.
 *
 * Side effects:
 *     None.
 *
 *--------------------------------------------------------------------------
 */
static int attrTest(eType, zString, zAttr)
    u8 eType;
    const char *zString;
    const char *zAttr;
{
    if (!zAttr) {
        return 0;
    }

    switch( eType ){
        /* True if the specified attribute exists */
        case CSS_SELECTOR_ATTR:
            return (zAttr?1:0);

        /* True if the specified attribute exists and the value matches
         * the string exactly.
         */
        case CSS_SELECTOR_ATTRVALUE:
            return ((zAttr && 0==stricmp(zAttr, zString))?1:0);

	/* Treat the attribute value (if it exists) as a space seperated list.
         * Return true if zString exists in the list.
         */
        case CSS_SELECTOR_ATTRLISTVALUE: {
            const char *pAttr = zAttr;
            int nAttr;
            int nString = strlen(zString);
            while ((pAttr=getNextListItem(pAttr, strlen(pAttr), &nAttr))) {
                if (nString==nAttr && 0==strncasecmp(pAttr, zString, nAttr)) {
                    return 1;
                }
                pAttr += nAttr;
            }
            return 0;
        }

        /* True if the attribute exists and matches zString up to the
         * first '-' character in the attribute value.
         */
        case CSS_SELECTOR_ATTRHYPHEN: {
            char *pHyphen = strchr(zAttr, '-');
            if( pHyphen && 0==strncasecmp(zAttr, zString, pHyphen-zAttr) ){
                return 1;
            }
            return 0;
        }
    }

    assert(!"Impossible");
    return 0;
}

/*--------------------------------------------------------------------------
 *
 * selectorTest --
 *
 *     Test if a selector matches a document node.
 *
 * Results:
 *     Non-zero is returned if the Selector does match the node.
 *
 * Side effects:
 *     None.
 *
 *--------------------------------------------------------------------------
 */
#define N_TYPE(x)        HtmlNodeTagName(x)
#define N_ATTR(x,y)      HtmlNodeAttr(x,y)
#define N_PARENT(x)      HtmlNodeParent(x)
#define N_NUMCHILDREN(x) HtmlNodeNumChildren(x)
#define N_CHILD(x,y)     HtmlNodeChild(x,y)
static int 
selectorTest(pSelector, pNode)
    CssSelector *pSelector;
    HtmlNode *pNode;
{
    CssSelector *p = pSelector;
    HtmlNode *x = pNode;
    while( p && x ){

        switch( p->eSelector ){
            case CSS_SELECTOR_UNIVERSAL:
                break;

            case CSS_SELECTOR_TYPE:
                if( strcmp(N_TYPE(x), p->zValue) ) return 0;
                break;

            case CSS_SELECTOR_ATTR:
            case CSS_SELECTOR_ATTRVALUE:
            case CSS_SELECTOR_ATTRLISTVALUE:
            case CSS_SELECTOR_ATTRHYPHEN:
                if( !attrTest(p->eSelector, p->zValue, N_ATTR(x,p->zAttr)) ){
                    return 0;
                }
                break;

            case CSS_SELECTORCHAIN_DESCENDANT: {
                HtmlNode *pParent = N_PARENT(x);
                CssSelector *pNext = p->pNext;
                while (pParent) {
                    if (selectorTest(pNext, pParent)) {
                        return 1;
                    }
                    pParent = N_PARENT(pParent);
                }
                return 0;
            }
            case CSS_SELECTORCHAIN_CHILD:
                x = N_PARENT(x);
                break;
            case CSS_SELECTORCHAIN_ADJACENT: {
                HtmlNode *pParent = N_PARENT(x);
                int i;
                for (i = 0; N_CHILD(pParent, i) != x; i++);
                if (i==0)  {
                    return 0;
                }
                x = N_CHILD(N_PARENT(x), i-1);
                break;
            }
                
            /* TODO: Support pseudo elements and classes properly. The
             * really important ones are ":visited" and ":link". ":active",
             * ":hover" and ":focus" are also pretty crucial to rendering
             * the web correctly.
             */
            case CSS_PSEUDOCLASS_LANG:
            case CSS_PSEUDOCLASS_FIRSTCHILD:
                return 0;
            case CSS_PSEUDOCLASS_LINK:
                /* Psuedo-class ":link". This rule matches any element with
                 * tag-type <a> and an href attribute.
                 */
                if (strcmp(N_TYPE(x), "a") ||
                    !attrTest(CSS_SELECTOR_ATTR, 0, N_ATTR(x,"href"))
                ) {
                    return 0;
                }
                break;
            case CSS_PSEUDOCLASS_VISITED:
            case CSS_PSEUDOCLASS_ACTIVE:
            case CSS_PSEUDOCLASS_HOVER:
            case CSS_PSEUDOCLASS_FOCUS:
            case CSS_PSEUDOELEMENT_FIRSTLINE:
            case CSS_PSEUDOELEMENT_FIRSTLETTER:
            case CSS_PSEUDOELEMENT_BEFORE:
            case CSS_PSEUDOELEMENT_AFTER:
                return 0;

            case CSS_SELECTOR_NEVERMATCH:
                return 0;

            default:
                assert(!"Impossible");
        }
        p = p->pNext;
    }

    return (x && !p)?1:0;
}

static void propertiesAdd(ppProperties, pRule)
    CssProperties **ppProperties;
    CssRule *pRule;
{
    CssProperties *pProperties = *ppProperties;
    int n = (pProperties?pProperties->nRule:0) + 1;
    int nAlloc = sizeof(CssProperties) + n*sizeof(CssRule *);

    assert( pRule );

    pProperties = (CssProperties *)ckrealloc((char *)pProperties, nAlloc);
    pProperties->nRule = n;
    pProperties->apRule = (CssRule **)&pProperties[1];
    pProperties->apRule[n-1] = pRule;

    *ppProperties = pProperties;
}

void HtmlCssPropertiesFree(pPropertySet)
    CssProperties *pPropertySet;
{
    if (pPropertySet) {
        ckfree((char *)pPropertySet);
    }
}

/*
 *---------------------------------------------------------------------------
 *
 * ruleToPropertyValues --
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static void 
ruleToPropertyValues(p, aPropDone, pRule)
    HtmlPropertyValuesCreator *p;
    int *aPropDone;
    CssRule *pRule;
{
    CssPropertySet *pSet = pRule->pPropertySet;
    int i;

    assert(pSet);

    for (i = 0; i < pSet->n; i++) {
        int eProp = pSet->a[i].eProp;
        assert(eProp <= CSS_PROPERTY_MAX_PROPERTY);
        if (0 == aPropDone[eProp]) {
            if (0 == HtmlPropertyValuesSet(p, eProp, pSet->a[i].pProp)) {
                aPropDone[eProp] = 1;
            }
        }
    }
}

/*--------------------------------------------------------------------------
 *
 * HtmlCssStyleSheetApply --
 *
 *     Argument pStyle contains the current stylesheet configuration for the
 *     document. It is assumed that pNode->pStyle contains the stylesheet
 *     parsed from any HTML style attribute attached to the node and that the
 *     nodes property cache has been allocated but not yet populated. Once this
 *     function returns, the property-cache of pNode is filled in with the
 *     styler output for the node.
 *
 * Results:
 *
 *     None.
 *
 * Side effects:
 *
 *--------------------------------------------------------------------------
 */
void 
HtmlCssStyleSheetApply(pTree, pNode)
    HtmlTree *pTree; 
    HtmlNode *pNode; 
{
    CssStyleSheet *pStyle = pTree->pStyle;    /* Stylesheet config */
    CssRule *pRule;                           /* Iterator variable */
    int style_done = 0;      /* Set after considering the html "style" attr */

    HtmlPropertyValuesCreator sCreator;

    /* The array aPropDone is large enough to contain an entry for each
     * property recognized by the CSS parser (approx 110, includes many that
     * Tkhtml does not use). After a property value is successfully written
     * into sCreator, the matching aPropDone entry is set to true.
     */
    int aPropDone[CSS_PROPERTY_MAX_PROPERTY + 1];

    /* Initialise aPropDone and sCreator */
    HtmlPropertyValuesInit(pTree, pNode, &sCreator);
    memset(aPropDone, 0, sizeof(aPropDone));
    assert(sizeof(aPropDone) == sizeof(int) * (CSS_PROPERTY_MAX_PROPERTY+1));

    /* Loop through the list of CSS rules in the stylesheet. Rules that occur
     * earlier in the list have a higher priority than those that occur later.
     */
    for (pRule = pStyle->pUniversalRules; pRule; pRule = pRule->pNext) {
        CssPriority *pPriority = pRule->pPriority;

        /* If this rule is not "!important", and is on either the user or
         * agent stylesheet, or has a specificity of less than or equal to
         * a single "id" selector, then the "style" attribute should be
         * considered before it.
         */
        if (!style_done && 
            !pPriority->important &&
            (pPriority->origin != CSS_ORIGIN_AUTHOR ||
             pRule->specificity <= 10000)
        ) {
            style_done = 1;
            if (pNode->pStyle) {
                CssRule *pRule2 = pNode->pStyle->apRule[0];
                assert(pNode->pStyle->nRule == 1);
                ruleToPropertyValues(&sCreator, aPropDone, pRule2);
            }
        }

        /* If the selector is a match for our node, apply the rule properties */
        if (selectorTest(pRule->pSelector, pNode)) {
            ruleToPropertyValues(&sCreator, aPropDone, pRule);
        }
    }

    if (!style_done && pNode->pStyle) {
        assert(pNode->pStyle->nRule == 1);
        ruleToPropertyValues(&sCreator, aPropDone, pNode->pStyle->apRule[0]);
    }

    /* Call HtmlPropertyValuesFinish() to finish creating teh
     * HtmlPropertyValues structure.
     */
    pNode->pPropertyValues = HtmlPropertyValuesFinish(&sCreator);
}

/*--------------------------------------------------------------------------
 *
 * HtmlCssPropertiesGet --
 *     Retrieve the value of a specified property from a CssProperties
 *     object, or NULL if the property is not defined.
 *
 * Results:
 *
 * Side effects:
 *
 *--------------------------------------------------------------------------
 */
CssProperty *
HtmlCssPropertiesGet(pProperties, prop, pSheetnum, pSpec)
    CssProperties * pProperties; 
    int prop;
    int *pSheetnum;
    int *pSpec;
{
    CssProperty *zRet = 0;
    if (pProperties) {
        int i;
        for (i=0; i<pProperties->nRule && !zRet; i++){
            CssPropertySet *pPropertySet = pProperties->apRule[i]->pPropertySet;
            zRet = propertySetGet(pPropertySet, prop);
            if (zRet) {
                if (pSheetnum)  {
                    *pSheetnum = pProperties->apRule[i]->pPriority->origin;
                }
                if (pSpec) {
                    *pSpec = pProperties->apRule[i]->specificity;
                }
            }
        }
    }
    return zRet;
}

/*
 *---------------------------------------------------------------------------
 *
 * HtmlCssSelectorComma --
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
void HtmlCssSelectorComma(pParse)
    CssParse *pParse;
{
    int n = (pParse->nXtra + 1) * sizeof(CssSelector *);
    pParse->apXtraSelector = 
       (CssSelector **)ckrealloc((char *)pParse->apXtraSelector, n);
    pParse->apXtraSelector[pParse->nXtra] = pParse->pSelector;
    pParse->pSelector = 0;
    pParse->nXtra++;
}

