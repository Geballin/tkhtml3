/*
 * Copyright (c) 2005 Eolas Technologies Inc.
 * All rights reserved.
 *
 * This Open Source project was made possible through the financial support
 * of Eolas Technologies Inc.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the <ORGANIZATION> nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
static const char rcsid[] = "$Id: css.c,v 1.52 2006/03/12 07:48:04 danielk1977 Exp $";

/*
 *    The CSS "cascade":
 *
 *        1. Find all declarations that apply to the element/property in
 *           question.  Declarations apply if the selector matches the
 *           element in question. If no declarations apply, the inherited
 *           value is used. If there is no inherited value (this is the
 *           case for the 'HTML' element and for properties that do not
 *           inherit), the initial value is used. 
 *       
 *        2. Sort the declarations by explicit weight: declarations marked
 *           '!important' carry more weight than unmarked (normal)
 *           declarations.  
 * 
 *        3. Sort by origin: the author's style sheets override the
 *           reader's style sheet which override the UA's default values.
 *           An imported style sheet has the same origin as the style sheet
 *           from which it is imported. 
 *
 *        4. Sort by specificity of selector: more specific selectors will
 *           override more general ones. To find the specificity, count the
 *           number of ID attributes in the selector (a), the number of
 *           CLASS attributes in the selector (b), and the number of tag
 *           names in the selector (c). Concatenating the three numbers (in
 *           a number system with a large base) gives the specificity. Some
 *           examples:
 *
 *        5. Sort by order specified: if two rules have the same weight,
 *           the latter specified wins. Rules in imported style sheets are
 *           considered to be before any rules in the style sheet itself.
 *
 *     As well as rules specified as part of stylesheets, property values
 *     may also come from:
 * 
 *           * Html style attributes. (i.e. <p style="...">). These
 *             properties are treated as if they were specified at the end
 *             of the author stylesheet with a single "id" selector.
 *
 *           * Other html attributes. (i.e. <p font="...">). These
 *             properties are treated as if they occured at the start of
 *             the author stylesheet with a single "type" selector.
 */

#include <stdlib.h>
#include <tcl.h>
#include <string.h>
#include <assert.h>
#include <stdio.h>
#include <errno.h>
#include <ctype.h>

#include "css.h"
#include "cssInt.h"
#include "html.h"

/*
 * Macros to trace code in this file. Set to non-zero to activate trace
 * output on stdout.
 */
#define TRACE_PARSER_CALLS 0
#define TRACE_STYLE_APPLICATION 0
#define TRACE_PROPERTY_PARSE 0

/* Declarations for the parser functions generated by lemon. These are used
 * by HtmlCssParse() and HtmlCssParseStyle().
 */
void *tkhtmlCssParserAlloc(void *(*)(size_t));
void tkhtmlCssParser(void *, int, CssToken, CssParse*);
void tkhtmlCssParserFree(void *, void (*)(void *));

static void propertiesAdd(CssProperties **, CssRule *);
static int cssGetToken(CONST char *, int , int *);
static int cssParse(int,CONST char*,int,int,Tcl_Obj*,Tcl_Obj*,Tcl_Interp*,Tcl_Obj*,CssStyleSheet**);

/*
 *---------------------------------------------------------------------------
 *
 * constantToString --
 *
 *     Transform an integer constant to it's string representation (for
 *     debugging). All of the constants defined in cssInt.h that start with
 *     CSS_* are supported.
 *
 * Results:
 *     Pointer to a static string.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
#if TRACE_PARSER_CALLS
static const char *constantToString(int c){
    switch( c ){
        case CSS_SELECTORCHAIN_DESCENDANT: 
            return "CSS_SELECTORCHAIN_DESCENDANT";
        case CSS_SELECTORCHAIN_CHILD: 
            return "CSS_SELECTORCHAIN_CHILD";
        case CSS_SELECTORCHAIN_ADJACENT: 
            return "CSS_SELECTORCHAIN_ADJACENT";
        case CSS_SELECTOR_UNIVERSAL: 
            return "CSS_SELECTOR_UNIVERSAL";
        case CSS_SELECTOR_TYPE: 
            return "CSS_SELECTOR_TYPE";
        case CSS_SELECTOR_ATTR: 
            return "CSS_SELECTOR_ATTR";
        case CSS_SELECTOR_ATTRVALUE: 
            return "CSS_SELECTOR_ATTRVALUE";
        case CSS_SELECTOR_ATTRLISTVALUE: 
            return "CSS_SELECTOR_ATTRLISTVALUE";
        case CSS_SELECTOR_ATTRHYPHEN: 
            return "CSS_SELECTOR_ATTRHYPHEN";
        case CSS_PSEUDOCLASS_LANG: 
            return "CSS_PSEUDOCLASS_LANG";
        case CSS_PSEUDOCLASS_FIRSTCHILD: 
            return "CSS_PSEUDOCLASS_FIRSTCHILD";
        case CSS_PSEUDOCLASS_LINK:  
            return "CSS_PSEUDOCLASS_LINK";
        case CSS_PSEUDOCLASS_VISITED: 
            return "CSS_PSEUDOCLASS_VISITED";
        case CSS_PSEUDOCLASS_ACTIVE:  
            return "CSS_PSEUDOCLASS_ACTIVE";
        case CSS_PSEUDOCLASS_HOVER: 
            return "CSS_PSEUDOCLASS_HOVER";
        case CSS_PSEUDOCLASS_FOCUS: 
            return "CSS_PSEUDOCLASS_FOCUS";
        case CSS_PSEUDOELEMENT_FIRSTLINE: 
            return "CSS_PSEUDOELEMENT_FIRSTLINE";
        case CSS_PSEUDOELEMENT_FIRSTLETTER: 
            return "CSS_PSEUDOELEMENT_FIRSTLETTER";
        case CSS_PSEUDOELEMENT_BEFORE: 
            return "CSS_PSEUDOELEMENT_BEFORE";
        case CSS_PSEUDOELEMENT_AFTER: 
            return "CSS_PSEUDOELEMENT_AFTER";
        case CSS_MEDIA_ALL: 
            return "CSS_MEDIA_ALL";
        case CSS_MEDIA_AURAL: 
            return "CSS_MEDIA_AURAL";
        case CSS_MEDIA_BRAILLE: 
            return "CSS_MEDIA_BRAILLE";
        case CSS_MEDIA_EMBOSSED: 
            return "CSS_MEDIA_EMBOSSED";
        case CSS_MEDIA_HANDHELD: 
            return "CSS_MEDIA_HANDHELD";
        case CSS_MEDIA_PRINT: 
            return "CSS_MEDIA_PRINT";
        case CSS_MEDIA_PROJECTION: 
            return "CSS_MEDIA_PROJECTION";
        case CSS_MEDIA_SCREEN: 
            return "CSS_MEDIA_SCREEN";
        case CSS_MEDIA_TTY: 
            return "CSS_MEDIA_TTY";
        case CSS_MEDIA_TV: 
            return "CSS_MEDIA_TV";
    }
    return "unknown";
}
#endif

/*--------------------------------------------------------------------------
 *
 * dequote --
 *
 *     This function is used to dequote a CSS string value. 
 * 
 *     Argument z is a pointer to a buffer containing a possibly quoted,
 *     null-terminated string. If it is quoted, then this function overwrites
 *     the buffer with the unquoted version. CSS strings may be quoted with
 *     single or double quotes. The quote character may occur within a string
 *     only if it is escaped with a "\" character.
 *
 * Results:
 *     None
 *
 * Side effects:
 *     May modify the contents of buffer pointed to by z.
 *
 *--------------------------------------------------------------------------
 */
static void 
dequote(z)
    char *z;
{
    if (z) {
        int n = strlen(z);;
        char q = z[0];
        if (n > 1 && (q == '"' || q == '\'') && z[n-1] == q && z[n-2] != '\\') {
            int i;
            char *zOut = z;
            for (i = 1; i < (n - 1); i++) {
                char o = z[i];
                if (o == '\\' && (z[i+1] == '\\' || z[i+1] == q)) {
                    o = z[++i];
                } 
                *zOut++ = o;
            }
            *zOut++ = 0;
        }
    }
}


/*--------------------------------------------------------------------------
 *
 * tokenToString --
 *
 *     This function returns a null-terminated string (allocated by HtmlAlloc)
 *     populated with the contents of the supplied token.
 *
 * Results:
 *     Null-terminated string. Caller is responsible for calling HtmlFree()
 *     on it.
 *
 * Side effects:
 *     None.
 *
 *--------------------------------------------------------------------------
 */
static char *tokenToString(CssToken *pToken){
    char *zRet;
    if( !pToken || pToken->n<=0 ){
         return 0;
    }
    zRet = (char *)HtmlAlloc(pToken->n+1);
    memcpy(zRet, pToken->z, pToken->n);
    zRet[pToken->n] = '\0';
    return zRet;
}

/*
 *---------------------------------------------------------------------------
 *
 * tokenToReal --
 *
 *     Try to convert the token pToken to a floating point number. The
 *     conversion is considered successful if pToken starts with anything
 *     that looks like a floating point number. "0.0px" and "0px" convert
 *     successfully, "px" does not. Return non-zero if the conversion is
 *     succcesful, else zero.
 *
 *     Write the floating point number to *pVal. Write the number of bytes
 *     convereted to *pLen.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static int tokenToReal(pToken, pLen, pVal)
    CssToken *pToken;
    int *pLen;
    double *pVal;
{
    char zBuf[100];
    char *zEnd;
    if (pToken->n>99) {
        return 0;
    }
    strncpy(zBuf, pToken->z, pToken->n);
    zBuf[pToken->n] = '\0';
    *pVal = strtod(zBuf, &zEnd);
    if (zEnd!=zBuf) {
        *pLen = (zEnd-zBuf);
        return 1;
    }
    return 0;
}

/*
 *---------------------------------------------------------------------------
 *
 * rgbToColor --
 *
 *     This function is invoked when a property value of the form 
 *     "rgb(rrr, ggg, bbb)" is encountered. This routine interprets the
 *     property and transforms it to a string of the form #AAAAAA which can
 *     be understood as a color by Tk.
 *
 *     The first argument, zOut, points to a buffer of not less than 8
 *     bytes. The output string and it's NULL terminator is written here.
 *     The second parameter, zRgb, points to the first byte past the '('
 *     character of the original property value. The final parameter, nRgb,
 *     is the number of bytes between the '(' and ')' character of the
 *     original property.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     Writes exactly 8 bytes to zOut.
 *
 *---------------------------------------------------------------------------
 */
static void 
rgbToColor(zOut, zRgb, nRgb)
    char *zOut;
    CONST char *zRgb;
    int nRgb;
{
    CONST char *z = zRgb;
    CONST char *zEnd = zRgb+nRgb;
    int n = 0;
    int aN[3] = {0, 0, 0};

    while (z < zEnd && n < 3) {
        while (!isdigit(*z) && *z!='.' && *z!='-' && *z!='+') z++;
        aN[n] = (int)strtod(z, (char **)&z);
        if (*z=='%') {
            aN[n] = ((aN[n] * 255) / 100);
        }
        aN[n] = MIN(aN[n], 255);
        aN[n] = MAX(aN[n], 0);
        n++;
    }

    n = sprintf(zOut, "#%.2x%.2x%.2x", aN[0], aN[1], aN[2]);
    assert(n==7);
}

static int
doUrlCmd(pParse, zArg, nArg)
    CssParse *pParse;
    CONST char *zArg;
    int nArg;
{
    const int eval_flags = TCL_EVAL_DIRECT|TCL_EVAL_GLOBAL;
    char *zCopy = HtmlAlloc(nArg + 1);
    Tcl_Obj *pCopy;
    Tcl_Obj *pScript = Tcl_DuplicateObj(pParse->pUrlCmd);

    memcpy(zCopy, zArg, nArg);
    zCopy[nArg] = '\0';
    dequote(zCopy);
    pCopy = Tcl_NewStringObj(zCopy, -1);

    Tcl_IncrRefCount(pScript);
    Tcl_ListObjAppendElement(0, pScript, pCopy);
    Tcl_EvalObjEx(pParse->interp, pScript, eval_flags);
    Tcl_DecrRefCount(pScript);

    HtmlFree(zCopy);

    return TCL_OK;
}

/*
 *---------------------------------------------------------------------------
 *
 * tokenToProperty --
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static CssProperty *
tokenToProperty(pParse, pToken)
    CssParse *pParse;
    CssToken *pToken;
{
    struct LengthFormat {
        int type;
        int len;
        char *zUnit;
    } lengths[] = {
        {CSS_TYPE_EM,         2, "em"},
        {CSS_TYPE_EX,         2, "ex"},
        {CSS_TYPE_PX,         2, "px"},
        {CSS_TYPE_PT,         2, "pt"},
        {CSS_TYPE_PERCENT,    1, "%"},
        {CSS_TYPE_FLOAT,      0, ""},
        {CSS_TYPE_CENTIMETER, 2, "cm"},
        {CSS_TYPE_MILLIMETER, 2, "mm"},
        {CSS_TYPE_INCH,       2, "in"},
        {CSS_TYPE_PC,         2, "pc"},
    };

    struct FunctionFormat {
        int type;
        int len;
        char *zFunc;
    } functions[] = {
        {CSS_TYPE_TCL, 3, "tcl"},
        {CSS_TYPE_URL, 3, "url"},
        {-1,           3, "rgb"},
    };

    CssProperty *pProp = 0;
    int i;
    double realval;       /* Real value, if token can be converted to float */
    int reallen;          /* Bytes of token converted to realval */

    CONST char *z = pToken->z;
    int n = pToken->n;

    /* Check if this is a length. It is a length if the token consists
     * of a floating point number followed by one of the units enumerated
     * above in the array of LengthFormat structs.
     */
    if (tokenToReal(pToken, &reallen, &realval)) {
        for (i=0; i<(sizeof(lengths)/sizeof(lengths[0])); i++) {
            CONST char *zTokenUnit = &z[reallen];
            if ((n-reallen)==lengths[i].len &&
                    0==strncmp(zTokenUnit, lengths[i].zUnit, lengths[i].len)) {
                pProp = (CssProperty *)HtmlAlloc(sizeof(CssProperty));
                pProp->eType = lengths[i].type;
                pProp->v.rVal = realval;
                break;
            }
        }
    }

    /* Check if this is a function call. A function call is anything that
     * begins with one or more alphabetic characters and a '(' character.
     * The last character of the token must be ')'.
     */
    if (z[n-1]==')') {
        for (i=0; i<n && isalpha((int)z[i]); i++);
        if (i<n && i>0 && z[i]=='(') {
            int l = i;
            int nFunc = sizeof(functions)/sizeof(struct FunctionFormat);
            for (i=0; pProp==0 && i<nFunc; i++) {
                if (l==functions[i].len && 0==strncmp(functions[i].zFunc,z,l)) {
                    char CONST *zArg;
                    int nArg;

                    zArg = &z[l+1];
                    nArg = (n-l-2); /* len(token)-len(func)-len('(')-len(')') */

                    if (
                        functions[i].type == CSS_TYPE_URL &&
                        pParse &&
                        pParse->pUrlCmd
                    ) {
                        doUrlCmd(pParse, zArg, nArg);
                        zArg = Tcl_GetStringResult(pParse->interp);
                        nArg = strlen(zArg);
                    }

                    if (functions[i].type==-1) {
                        /* -1 means this is an RGB value. Transform to a
                         * color string that Tcl can understand before
			 * storing it in the properties database. The color
			 * string will be 7 characters long exactly.
                         */
                        int nAlloc = sizeof(CssProperty) + 7 + 1;
                        pProp = (CssProperty *)HtmlAlloc(nAlloc);
                        pProp->eType = CSS_TYPE_STRING;
                        pProp->v.zVal = (char *)&pProp[1];
                        rgbToColor(pProp->v.zVal, zArg, nArg);
                    } else {
                        int nAlloc = sizeof(CssProperty) + nArg + 1;
                        pProp = (CssProperty *)HtmlAlloc(nAlloc);
                        pProp->eType = functions[i].type;
                        pProp->v.zVal = (char *)&pProp[1];
                        strncpy(pProp->v.zVal, zArg, nArg);
                        pProp->v.zVal[nArg] = '\0';
                    }

                    if (pProp->eType == CSS_TYPE_URL) {
                        dequote(pProp->v.zVal);
                    }
                    break;
                }
            }
        }
    }

    /* Finally, treat the property as a generic string. v.zVal will point at
     * a NULL-terminated copy of the string. The eType field is set to
     * either CSS_TYPE_STRING, or one of the symbols in cssprop.h (i.e.
     * CSS_TYPE_BLOCK).
     */
    if (!pProp) {
        int eType;
        pProp = (CssProperty *)HtmlAlloc(sizeof(CssProperty)+(n+1));
        pProp->v.zVal = (char *)&pProp[1];
        memcpy(pProp->v.zVal, z, n);
        pProp->v.zVal[n] = '\0';

        eType = HtmlCssConstantLookup(-1, pProp->v.zVal);
        pProp->eType = eType > 0 ? eType : CSS_TYPE_STRING;

        if (pProp->eType == CSS_TYPE_STRING) {
            dequote(pProp->v.zVal);
        }
    }
    return pProp;
}

/*
 *---------------------------------------------------------------------------
 *
 * textToProperty --
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static CssProperty *
textToProperty(pParse, z, n)
    CssParse *pParse;
    CONST char *z;
    int n;
{
    CssToken token;
    token.n = (n < 0) ? strlen(z): n;
    token.z = z;
    return tokenToProperty(pParse, &token);
}

/*
 *---------------------------------------------------------------------------
 *
 * HtmlCssStringToProperty --
 *
 *     This is an externally available interface to convert the property
 *     value string pointed to by z, length n, to a property object. The
 *     caller should call HtmlFree() on the return value when it has finished
 *     with it.
 *
 * Results:
 *     Allocated CssProperty object.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
CssProperty *HtmlCssStringToProperty(z, n)
    CONST char *z; 
    int n;
{
    CssToken sToken;
    if (n<0) {
        n = strlen(z);
    }
    sToken.z = z;
    sToken.n = n;
    return tokenToProperty(0, &sToken);
}

/*
 *---------------------------------------------------------------------------
 *
 * HtmlCssPropertyGetString --
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
CONST char *
HtmlCssPropertyGetString(pProp)
    CssProperty *pProp;
{
    if (pProp) {
        int eType = pProp->eType;
        if (eType == CSS_TYPE_STRING || 
            (eType >= CSS_CONST_MIN_CONSTANT && eType <= CSS_CONST_MAX_CONSTANT)
        ) {
            return pProp->v.zVal;
        }
    }
    return 0;
}

/*--------------------------------------------------------------------------
 *
 * propertySetNew --
 *
 *     Allocate a new (empty) property set. The caller should eventually
 *     delete the property set using propertySetFree().
 *
 * Results:
 *     An empty property set.
 *
 * Side effects:
 *     None.
 *
 *--------------------------------------------------------------------------
 */
static CssPropertySet *
propertySetNew(){
    CssPropertySet *p = (CssPropertySet *)HtmlAlloc(sizeof(CssPropertySet));
    if( p ){
        memset(p, 0, sizeof(CssPropertySet));
    }
    return p;
}

/*--------------------------------------------------------------------------
 *
 * propertySetGet --
 *
 *     Retrieve CSS property 'i' if present in the property-set. 
 *
 * Results:
 *
 *     Return NULL if the property is not present, or a pointer to the
 *     value if it is.
 *
 * Side effects:
 *     None.
 *
 *--------------------------------------------------------------------------
 */
static CssProperty *
propertySetGet(p, i)
    CssPropertySet *p;         /* Property set */
    int i;                     /* Property id (i.e CSS_PROPERTY_WIDTH) */
{
    int j;
    assert( i<128 && i>=0 );

    for (j = 0; j < p->n; j++) {
        if (i == p->a[j].eProp) {
            return p->a[j].pProp;
        }
    }

    return 0;
}

/*--------------------------------------------------------------------------
 *
 * propertySetAdd --
 *
 *     Insert or replace a value into a property set.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *--------------------------------------------------------------------------
 */
static void 
propertySetAdd(p, i, v)
    CssPropertySet *p;         /* Property set. */
    int i;                     /* Property id (i.e CSS_PROPERTY_WIDTH). */
    CssProperty *v;            /* Value for property. */
{
    int j;
    int nBytes;

    assert( i<128 && i>=0 );

    assert(!p->a || p->n > 0);

    for (j = 0; j < p->n; j++) {
        if (i == p->a[j].eProp) {
            HtmlFree((char *)p->a[j].pProp);
            p->a[j].pProp = v;
            return;
        }
    }

    nBytes = (p->n + 1) * sizeof(struct CssPropertySetItem);
    p->a = (struct CssPropertySetItem *)HtmlRealloc((char *)p->a, nBytes);
    p->a[p->n].pProp = v;
    p->a[p->n].eProp = i;
    p->n++;
}

/*--------------------------------------------------------------------------
 *
 * propertySetFree --
 *
 *     Delete a property set and it's contents.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *--------------------------------------------------------------------------
 */
static void 
propertySetFree(CssPropertySet *p){
    int i;
    if( !p ) return;
    for (i = 0; i < p->n; i++) {
        HtmlFree((char *)p->a[i].pProp);
    }
    HtmlFree((char *)p->a);
    HtmlFree((char *)p);
}

/*
 *---------------------------------------------------------------------------
 *
 * propertyDup --
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static CssProperty *propertyDup(pProp)
    CssProperty *pProp;
{
    CssProperty *pRet = (CssProperty *)HtmlAlloc(sizeof(CssProperty));
    memcpy(pRet, pProp, sizeof(CssProperty));
    return pRet;
}

/*
 *---------------------------------------------------------------------------
 *
 * propertyIsLength --
 *
 *     Return true if the property passed as the first argument is a length
 *     property. (i.e. pixels, em, percentage etc.)
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static int propertyIsLength(pProp)
    CssProperty *pProp;
{
    return (
        pProp->eType==CSS_TYPE_EM ||
        pProp->eType==CSS_TYPE_PT ||
        pProp->eType==CSS_TYPE_PC ||
        pProp->eType==CSS_TYPE_EX ||
        pProp->eType==CSS_TYPE_PX ||
        pProp->eType==CSS_TYPE_PERCENT
    );
}

/*
 *---------------------------------------------------------------------------
 *
 * getNextListItem --
 *
 *     Return the first property from a space seperated list of properties.
 *
 *     The property list is stored in string zList, length nList.
 *
 *     A pointer to the first property is returned. The length of the first
 *     property is stored in *pN.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static CONST char *
getNextListItem(zList, nList, pN)
    CONST char *zList;
    int nList;
    int *pN;
{
    int n = 0;
    int t = CT_SPACE;
    CONST char *zRet = 0;
    CONST char *z = zList;
    CONST char *zEnd = zList+nList;

    while (z<zEnd && t==CT_SPACE) {
        t = cssGetToken(z, zEnd-z, &n);
        assert(n>0);
        if (t==CT_SPACE) {
            z += n;
        }
    }
    zRet = z;
    z += n;

    while (z<zEnd && t!=CT_SPACE) {
        int n2 = 0;
        t = cssGetToken(z, zEnd-z, &n2);
        assert(n2>0);
        z += n2;
        if (t!=CT_SPACE) {
            n += n2;
        }
    }

    if (zRet<zEnd && n>0) {
        assert(n<=nList);
        *pN = n;
        return zRet;
    }
    return 0;
}

/*
 *---------------------------------------------------------------------------
 *
 * propertySetAddShortcutBorder --
 *
 *     Devolve the shortcut property 'border' into it's sub-properties and
 *     add the results to a CssPropertySet.
 *
 *     A 'border' property consists of a white-space seperated list of at
 *     most three quantities. Any of the three quantities may be omitted,
 *     but the order remains the same.
 *
 *     [<border-width>] [<border-style>] [<border-color>]
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static void propertySetAddShortcutBorder(p, prop, v)
    CssPropertySet *p;         /* Property set. */
    int prop;
    CssToken *v;               /* Value for property. */
{
    CONST char *z = v->z;
    CONST char *zEnd = z + v->n;
    int n;

    int aWidth[] = {
        CSS_PROPERTY_BORDER_TOP_WIDTH,
        CSS_PROPERTY_BORDER_RIGHT_WIDTH,
        CSS_PROPERTY_BORDER_BOTTOM_WIDTH,
        CSS_PROPERTY_BORDER_LEFT_WIDTH,
    };
    int aStyle[] = {
        CSS_PROPERTY_BORDER_TOP_STYLE,
        CSS_PROPERTY_BORDER_RIGHT_STYLE,
        CSS_PROPERTY_BORDER_BOTTOM_STYLE,
        CSS_PROPERTY_BORDER_LEFT_STYLE,
    };
    int aColor[] = {
        CSS_PROPERTY_BORDER_TOP_COLOR,
        CSS_PROPERTY_BORDER_RIGHT_COLOR,
        CSS_PROPERTY_BORDER_BOTTOM_COLOR,
        CSS_PROPERTY_BORDER_LEFT_COLOR,
    };

    int iOffset = 0;        /* Offset in aWidth[], aStyle[], aColor[] */
    int nProp = 1;          /* Number of properties to set */
    switch (prop) {
        case CSS_SHORTCUTPROPERTY_BORDER:
            nProp = 4;
            break;
        case CSS_SHORTCUTPROPERTY_BORDER_TOP:
            break;
        case CSS_SHORTCUTPROPERTY_BORDER_RIGHT:
            iOffset = 1;
            break;
        case CSS_SHORTCUTPROPERTY_BORDER_BOTTOM:
            iOffset = 2;
            break;
        case CSS_SHORTCUTPROPERTY_BORDER_LEFT:
            iOffset = 3;
            break;
        default:
            assert(0);
    }

    while (z) {
        z = getNextListItem(z, zEnd-z, &n);
        if (z) {
            int *aProp = 0;
            CssToken token;
            CssProperty *pProp;
            int i;
            int eType;

            token.z = z;
            token.n = n;
            pProp = tokenToProperty(0, &token);
            eType = pProp->eType;

            if (propertyIsLength(pProp) || eType==CSS_TYPE_FLOAT) {
                aProp = aWidth;
            } else if (
                eType == CSS_CONST_NONE   || eType == CSS_CONST_HIDDEN ||
                eType == CSS_CONST_DOTTED || eType == CSS_CONST_DASHED ||
                eType == CSS_CONST_SOLID  || eType == CSS_CONST_DOUBLE ||
                eType == CSS_CONST_GROOVE || eType == CSS_CONST_RIDGE  ||
                eType == CSS_CONST_OUTSET || eType == CSS_CONST_INSET 
            ) {
                aProp = aStyle;
            } else if (
                eType == CSS_CONST_THIN || eType == CSS_CONST_THICK ||
                eType == CSS_CONST_MEDIUM
            ) {
                aProp = aWidth;
            } else {
                aProp = aColor;
            }

            for (i = iOffset; i < iOffset+nProp; i++) {
                if (i != iOffset) {
                    pProp = propertyDup(pProp);
                }
                propertySetAdd(p, aProp[i], pProp);
            }
            
            assert(n>0);
            z += n;
        }
    }
}

/*
 *---------------------------------------------------------------------------
 *
 * propertyTransformBgPosition --
 *
 *     This function is called on values that might be assigned to the
 *     'background-position' property. If the property contains one of the
 *     following constants, it is overwritten with the corresponding percentage
 *     value before this function returns.
 *
 *         'top'    -> 0%
 *         'left'   -> 0%
 *         'bottom' -> 100%
 *         'right'  -> 100%
 *         'center' -> 50%
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static void
propertyTransformBgPosition(pProp)
    CssProperty *pProp;
{
    double rVal;
    switch (pProp->eType) {
        case CSS_CONST_RIGHT:
        case CSS_CONST_BOTTOM:
            rVal = 100.0; 
            break;

        case CSS_CONST_CENTER:
            rVal = 50.0; 
            break;
 
        case CSS_CONST_TOP:
        case CSS_CONST_LEFT:
            rVal = 0.0; 
            break;

        default: 
            return;
    }

    pProp->eType = CSS_TYPE_PERCENT;
    pProp->v.rVal = rVal;
}

/*
 *---------------------------------------------------------------------------
 *
 * shortcutBackground --
 *
 *     This function is called to handle the short cut property 'background'.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static void 
shortcutBackground(pParse, p, v)
    CssParse *pParse;
    CssPropertySet *p;         /* Property set */
    CssToken *v;               /* Value for 'background' property */
{
    CONST char *z= v->z;
    CONST char *zEnd = z + v->n;
    int nProp = 0;
    int ii;

    CssProperty *pColor = 0;
    CssProperty *pImage = 0;
    CssProperty *pRepeat = 0;
    CssProperty *pAttachment = 0;
    CssProperty *pPositionX = 0;
    CssProperty *pPositionY = 0;

    CssProperty *apProp[6];
    while (z && nProp<6) {
        int n;
        z = getNextListItem(z, zEnd-z, &n);
        if (z) {
            CssToken token;
            token.z = z;
            token.n = n;
            apProp[nProp] = tokenToProperty(pParse, &token);
            nProp++;
            assert(n>0);
            z += n;
        }
    }

    for (ii = 0; ii < nProp; ii++) {
        CssProperty *pProp = apProp[ii];
        if (propertyIsLength(pProp)) {
            if (!pPositionX) {
                pPositionX = pProp;
            } else {
                if (pPositionY) goto error_out;
                pPositionY = pProp;
            }
        } else {
            switch (pProp->eType) {
                case CSS_CONST_SCROLL:
                case CSS_CONST_FIXED:
                    if (pAttachment) goto error_out;
                    pAttachment = pProp;
                    break;

                case CSS_CONST_REPEAT:
                case CSS_CONST_NO_REPEAT:
                case CSS_CONST_REPEAT_X:
                case CSS_CONST_REPEAT_Y:
                    if (pRepeat) goto error_out;
                    pRepeat = pProp;
                    break;

                case CSS_TYPE_URL:
                case CSS_CONST_NONE:
                    if (pImage) goto error_out;
                    pImage = pProp;
                    break;

                case CSS_CONST_TOP:
                case CSS_CONST_BOTTOM:
                    if (pPositionY) goto error_out;
                    propertyTransformBgPosition(pProp);
                    pPositionY = pProp;
                    break;

                case CSS_CONST_RIGHT:
                case CSS_CONST_LEFT:
                    if (pPositionX) goto error_out;
                    propertyTransformBgPosition(pProp);
                    pPositionX = pProp;
                    break;

                case CSS_CONST_CENTER:
                    propertyTransformBgPosition(pProp);
                    if (!pPositionX) {
                        pPositionX = pProp;
                    } else {
                        if (pPositionY) goto error_out;
                        pPositionY = pProp;
                    }
                    break;

                default:
                    if (pColor) goto error_out;
                    pColor = pProp;
                    break;
            }
        }
    }

    if (
        pPositionX && pPositionY && 
        ((pPositionX->eType == CSS_TYPE_PERCENT) ? 1 : 0) !=
        ((pPositionY->eType == CSS_TYPE_PERCENT) ? 1 : 0)
    ) {
        goto error_out;
    }

    if (pImage) {
        propertySetAdd(p, CSS_PROPERTY_BACKGROUND_IMAGE, pImage);
    }
    if (pAttachment) {
        propertySetAdd(p, CSS_PROPERTY_BACKGROUND_ATTACHMENT, pAttachment);
    }
    if (pColor) {
        propertySetAdd(p, CSS_PROPERTY_BACKGROUND_COLOR, pColor);
    }
    if (pRepeat) {
        propertySetAdd(p, CSS_PROPERTY_BACKGROUND_REPEAT, pRepeat);
    }
    if (pPositionX) {
        propertySetAdd(p, CSS_PROPERTY_BACKGROUND_POSITION_X, pPositionX);
        if (!pPositionY) {
            pPositionY = propertyDup(pPositionX);
        }
    }
    if (pPositionY) {
        propertySetAdd(p, CSS_PROPERTY_BACKGROUND_POSITION_Y, pPositionY);
    }

    return;

error_out:
    for (ii = 0; ii < nProp; ii++) {
        HtmlFree((char *)apProp[ii]);
    }
}
/*
 *---------------------------------------------------------------------------
 *
 * shortcutListStyle --
 *
 * 	[ <'list-style-type'> || <'list-style-position'> ||
 * 	    <'list-style-image'> ] | inherit
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static void
shortcutListStyle(pParse, p, v)
    CssParse *pParse;
    CssPropertySet *p;         /* Property set */
    CssToken *v;               /* Value for 'list-style' property */
{
    CONST char *z= v->z;
    CONST char *zEnd = z + v->n;

    CssProperty *pType = 0;
    CssProperty *pPosition = 0;
    CssProperty *pImage = 0;
    CssProperty *pProp = 0;

    while (z) {
        int n;
        z = getNextListItem(z, zEnd-z, &n);
        if (z) {
            pProp = textToProperty(pParse, z, n);
            switch (pProp->eType) {
                case CSS_CONST_INHERIT:
                    if (pType || pPosition || pImage) {
                        goto bad_parse;
                    }
                    pType = pProp;
                    pPosition = propertyDup(pProp);
                    pImage = propertyDup(pProp);
                    z = 0;
                    break;

                case CSS_CONST_INSIDE:
                case CSS_CONST_OUTSIDE:
                    if (pPosition) goto bad_parse;
                    pPosition = pProp;
                    break;

                case CSS_TYPE_URL:
                case CSS_TYPE_STRING:
                    if (pImage) goto bad_parse;
                    pImage = pProp;
                    break;

                case CSS_CONST_DISC:
                case CSS_CONST_CIRCLE:
                case CSS_CONST_SQUARE:
                case CSS_CONST_NONE:
                case CSS_CONST_DECIMAL:
                case CSS_CONST_LOWER_ALPHA:
                case CSS_CONST_UPPER_ALPHA:
                case CSS_CONST_LOWER_ROMAN:
                case CSS_CONST_UPPER_ROMAN:
                    if (pType) goto bad_parse;
                    pType = pProp;
                    break;

                default:
                    goto bad_parse;
            }
            if (z) {
                z += n;
            }
        }
    }

    propertySetAdd(p, CSS_PROPERTY_LIST_STYLE_TYPE, pType);
    propertySetAdd(p, CSS_PROPERTY_LIST_STYLE_POSITION, pPosition);
    propertySetAdd(p, CSS_PROPERTY_LIST_STYLE_IMAGE, pImage);

    return;

bad_parse:
    if (pProp) HtmlFree((char *)pProp);
    if (pImage) HtmlFree((char *)pImage);
    if (pPosition) HtmlFree((char *)pPosition);
    if (pType) HtmlFree((char *)pType);
}

/*
 *---------------------------------------------------------------------------
 *
 * propertySetAddShortcutFont --
 *
 *     [ <font-style> || <font-variant> || <font-weight> ]? 
 *         <font-size> [ / <line-height> ]? <font-family>
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static void
propertySetAddShortcutFont(p, v)
    CssPropertySet *p;         /* Property set */
    CssToken *v;               /* Value for 'background' property */
{
    CONST char *z= v->z;
    CONST char *zEnd = z + v->n;

    CssProperty *pStyle = 0;
    CssProperty *pVariant = 0;
    CssProperty *pWeight = 0;
    CssProperty *pSize = 0;
    CssProperty *pLineHeight = 0;
    CssProperty *pFamily = 0;

    CssProperty *pProp = 0;

    while (z) {
        int n;
        z = getNextListItem(z, zEnd-z, &n);
        if (z) {
            pProp = textToProperty(0, z, n);
            switch (pProp->eType) {
                case CSS_CONST_INHERIT:
                    if (pStyle || pVariant || pWeight || 
                            pSize || pLineHeight || pFamily
                    ) {
                        goto bad_parse;
                    }
                    pStyle = pProp;
                    pVariant = propertyDup(pProp);
                    pWeight = propertyDup(pProp);
                    pSize = propertyDup(pProp);
                    pLineHeight = propertyDup(pProp);
                    pFamily = propertyDup(pProp);
                    z = 0;
                    break;

                case CSS_CONST_NORMAL:
                    HtmlFree((char *)pProp);
                    break;
    
                case CSS_CONST_ITALIC:
                case CSS_CONST_OBLIQUE:
                    if (pStyle) goto bad_parse;
                    pStyle = pProp;
                    break;
    
                case CSS_CONST_BOLD:
                case CSS_CONST_BOLDER:
                case CSS_CONST_LIGHTER:
                case CSS_TYPE_FLOAT:
                    if (pWeight) goto bad_parse;
                    pWeight = pProp;
                    break;
    
                case CSS_CONST_SMALL_CAPS:
                    if (pVariant) goto bad_parse;
                    pVariant = pProp;
                    break;

                default: {
                    int hasLineHeight = 0;
                    if (pProp->eType == CSS_TYPE_STRING) {
                        int j;
                        for (j = 0; j < n && z[j] != '/'; j++);
                        if (j == n) goto bad_parse;
                        HtmlFree((char *)pProp);
                        n = j;
                        pProp = textToProperty(0, z, j);
                    } 
                    pSize = pProp;
                    pProp = 0;
                    z += n;
                    while (isspace(*z) || *z == '/') {
                        if (*z == '/') hasLineHeight = 1;
                        z++;
                    }
    
                    if (hasLineHeight) {
                        z = getNextListItem(z, zEnd-z, &n);
                        pLineHeight = textToProperty(0, z, n);
                        z += n;
                    } 
                    z = getNextListItem(z, zEnd-z, &n);
                    if (!z) goto bad_parse;
                    pFamily = textToProperty(0, z, zEnd-z);
                    z = 0;
               }
            }

            if (z) {
                z += n;
            }
        }
    }

    if (!pFamily) goto bad_parse;

    propertySetAdd(p, CSS_PROPERTY_FONT_STYLE, pStyle);
    propertySetAdd(p, CSS_PROPERTY_FONT_VARIANT, pVariant);
    propertySetAdd(p, CSS_PROPERTY_FONT_WEIGHT, pWeight);
    propertySetAdd(p, CSS_PROPERTY_FONT_SIZE, pSize);
    propertySetAdd(p, CSS_PROPERTY_FONT_FAMILY, pFamily);
    propertySetAdd(p, CSS_PROPERTY_LINE_HEIGHT, pLineHeight);

    return;

bad_parse:
    if (pProp) HtmlFree((char *)pProp);
    if (pStyle) HtmlFree((char *)pStyle);
    if (pVariant) HtmlFree((char *)pVariant);
    if (pWeight) HtmlFree((char *)pWeight);
    if (pSize) HtmlFree((char *)pSize);
    if (pFamily) HtmlFree((char *)pFamily);
    if (pLineHeight) HtmlFree((char *)pLineHeight);
}


/*
 *---------------------------------------------------------------------------
 *
 * propertySetAddShortcutBackgroundPosition --
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static void 
propertySetAddShortcutBackgroundPosition(p, v)
    CssPropertySet *p;         /* Property set */
    CssToken *v;               /* Value for 'background' property */
{
    CONST char *z= v->z;
    CONST char *zEnd = z + v->n;
    int i = 0;
    CssProperty *apProp[4];

    while (z && i<2) {
        int n;
        z = getNextListItem(z, zEnd-z, &n);
        if (z) {
            CssToken token;
            token.z = z;
            token.n = n;
            apProp[i] = tokenToProperty(0, &token);
            i++;
            assert(n>0);
            z += n;
        }
    }


    if (i > 0) {
        assert(i == 1 || i == 2);
        if (i == 1) {
            apProp[1] = propertyDup(apProp[0]);
        }   

        if (
            apProp[0]->eType == CSS_CONST_TOP     || 
            apProp[0]->eType == CSS_CONST_BOTTOM  ||
            apProp[1]->eType == CSS_CONST_LEFT    || 
            apProp[1]->eType == CSS_CONST_RIGHT
        ) {
            CssProperty *pProp = apProp[0];
            apProp[0] = apProp[1];
            apProp[1] = pProp;
        }
        if (
            apProp[0]->eType == CSS_CONST_TOP     || 
            apProp[0]->eType == CSS_CONST_BOTTOM  ||
            apProp[1]->eType == CSS_CONST_LEFT    || 
            apProp[1]->eType == CSS_CONST_RIGHT
        ) {
            HtmlFree(apProp[0]);
            HtmlFree(apProp[1]);
            return;
        }

        propertyTransformBgPosition(apProp[0]);
        propertyTransformBgPosition(apProp[1]);
        propertySetAdd(p, CSS_PROPERTY_BACKGROUND_POSITION_X, apProp[0]);
        propertySetAdd(p, CSS_PROPERTY_BACKGROUND_POSITION_Y, apProp[1]);
    }
}

/*
 *---------------------------------------------------------------------------
 *
 * propertySetAddShortcutBorderColor --
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static void propertySetAddShortcutBorderColor(p, prop, v)
    CssPropertySet *p;         /* Property set. */
    int prop;
    CssToken *v;               /* Value for property. */
{
    CONST char *z= v->z;
    CONST char *zEnd = z + v->n;
    int n;

    int i = 0;                 /* Index of apProp to read next color in to */
    CssProperty *apProp[4];    /* Array of color properties */
    memset(apProp, 0, sizeof(CssProperty *)*4);

    while (z && i<4) {
        z = getNextListItem(z, zEnd-z, &n);
        if (z) {
            CssToken token;
            token.z = z;
            token.n = n;
            apProp[i] = tokenToProperty(0, &token);
            i++;
            assert(n>0);
            z += n;
        }
    }

    switch (i) {
        case 1:
            apProp[1] = propertyDup(apProp[0]);
            apProp[2] = propertyDup(apProp[0]);
            apProp[3] = propertyDup(apProp[0]);
            break;
        case 2:
            apProp[2] = propertyDup(apProp[0]);
            apProp[3] = propertyDup(apProp[1]);
            break;
        case 3:
            apProp[3] = propertyDup(apProp[1]);
            break;
        case 4:
            break;
        default:
            return;
    }

    switch (prop) {
        case CSS_SHORTCUTPROPERTY_BORDER_COLOR:
            propertySetAdd(p, CSS_PROPERTY_BORDER_TOP_COLOR, apProp[0]);
            propertySetAdd(p, CSS_PROPERTY_BORDER_RIGHT_COLOR, apProp[1]);
            propertySetAdd(p, CSS_PROPERTY_BORDER_BOTTOM_COLOR, apProp[2]);
            propertySetAdd(p, CSS_PROPERTY_BORDER_LEFT_COLOR, apProp[3]);
            break;
        case CSS_SHORTCUTPROPERTY_BORDER_STYLE:
            propertySetAdd(p, CSS_PROPERTY_BORDER_TOP_STYLE, apProp[0]);
            propertySetAdd(p, CSS_PROPERTY_BORDER_RIGHT_STYLE, apProp[1]);
            propertySetAdd(p, CSS_PROPERTY_BORDER_BOTTOM_STYLE, apProp[2]);
            propertySetAdd(p, CSS_PROPERTY_BORDER_LEFT_STYLE, apProp[3]);
            break;
        case CSS_SHORTCUTPROPERTY_BORDER_WIDTH:
            propertySetAdd(p, CSS_PROPERTY_BORDER_TOP_WIDTH, apProp[0]);
            propertySetAdd(p, CSS_PROPERTY_BORDER_RIGHT_WIDTH, apProp[1]);
            propertySetAdd(p, CSS_PROPERTY_BORDER_BOTTOM_WIDTH, apProp[2]);
            propertySetAdd(p, CSS_PROPERTY_BORDER_LEFT_WIDTH, apProp[3]);
            break;
        case CSS_SHORTCUTPROPERTY_PADDING:
            propertySetAdd(p, CSS_PROPERTY_PADDING_TOP, apProp[0]);
            propertySetAdd(p, CSS_PROPERTY_PADDING_RIGHT, apProp[1]);
            propertySetAdd(p, CSS_PROPERTY_PADDING_BOTTOM, apProp[2]);
            propertySetAdd(p, CSS_PROPERTY_PADDING_LEFT, apProp[3]);
            break;
        case CSS_SHORTCUTPROPERTY_MARGIN:
            propertySetAdd(p, CSS_PROPERTY_MARGIN_TOP, apProp[0]);
            propertySetAdd(p, CSS_PROPERTY_MARGIN_RIGHT, apProp[1]);
            propertySetAdd(p, CSS_PROPERTY_MARGIN_BOTTOM, apProp[2]);
            propertySetAdd(p, CSS_PROPERTY_MARGIN_LEFT, apProp[3]);
            break;
    }
}

/*--------------------------------------------------------------------------
 *
 * selectorFree --
 *
 *     Delete a linked list of CssSelector structs, including the 
 *     CssSelector.zValue and CssSelector.zAttr fields.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *--------------------------------------------------------------------------
 */
static void selectorFree(pSelector)
    CssSelector *pSelector;
{
    if( !pSelector ) return;
    selectorFree(pSelector->pNext);
    HtmlFree(pSelector->zValue);
    HtmlFree(pSelector->zAttr);
    HtmlFree((char *)pSelector);
}

/*
 *---------------------------------------------------------------------------
 *
 * cssGetToken --
 *
 *     Return the id of the next CSS token in the string pointed to by z,
 *     length n. The length of the token is written to *pLen. 0 is returned
 *     if there are no complete tokens remaining.
 *
 * Results:
 *     See above.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static int 
cssGetToken(z, n, pLen)
    CONST char *z; 
    int n; 
    int *pLen;
{
    if( n<=0 ){
      return 0;
    }

    *pLen = 1;
    switch( z[0] ){
        case ' ':
        case '\n':
        case '\t': return CT_SPACE;
        case '{':  return CT_LP;
        case '}':  return CT_RP;
        case ')':  return CT_RRP;
        case '[':  return CT_LSP;
        case ']':  return CT_RSP;
        case ';':  return CT_SEMICOLON;
        case ',':  return CT_COMMA;
        case ':':  return CT_COLON;
        case '+':  return CT_PLUS;
        case '>':  return CT_GT;
        case '*':  return CT_STAR;
        case '.':  return CT_DOT;
        case '#':  return CT_HASH;
        case '=':  return CT_EQUALS;
        case '~':  return CT_TILDE;
        case '|':  return CT_PIPE;
        case '/':  {
            int i;
            int c;
            if( z[1]!='*' || z[2]==0 ){
                return CT_SLASH;
            }
            for(i=3, c=z[2]; (c!='*' || z[i]!='/') && (c=z[i])!=0; i++){}
            if( c ) i++;
            *pLen = i;
            return -1;
        }

        case '"': case '\'': {
            char delim = z[0];
            char c;
            int i;
            for(i=1; i<n; i++){
                c = z[i];
                if( c=='\\' ){
                    i++;
                }
                if( c==delim ){
                    *pLen = i+1; 
                    return CT_STRING;
                }
            }
            *pLen = n;
            return -1;
        }

        case '@': {
            struct AtKeyWord {
                const char *z;
                int n;
                int t;
            } atkeywords[] = {
                {"import",    6, CT_IMPORT_SYM},
                {"page",      4, CT_PAGE_SYM},
                {"media",     5, CT_MEDIA_SYM},
                {"font-face", 9, CT_FONT_SYM},
                {"charset",   7, CT_CHARSET_SYM},
            };
            int i;
            for(i=0; i<sizeof(atkeywords)/sizeof(struct AtKeyWord); i++){
                if( 0==strncmp(&z[1], atkeywords[i].z, atkeywords[i].n) ){
                    *pLen = atkeywords[i].n + 1;
                    return atkeywords[i].t;
                }
            }
            goto bad_token;
        }
        case '!': {
            int a = 1;
            while (z[a] && isspace(z[a])) a++; 
            if( 0==strncmp(&z[a], "important", 9) ){
                 *pLen = 9 + a;
                 return CT_IMPORTANT_SYM;
            }
            goto bad_token;
        }

        default: {
            /* Weed out HTML comment symbols: <!-- and --> */
            if (n >= 4 && 0 == strncmp("<!--", z, 4)) {
                *pLen = 4;
                return -1;
            }
            if (n >= 3 && 0 == strncmp("-->", z, 3)) {
                *pLen = 3;
                return -1;
            }
                
            /* This must be either an identifier or a function. For the
            ** ASCII character range 0-127, the 'charmap' array is 1 for
            ** characters allowed in an identifier or function name, 0
            ** for characters not allowed. Allowed characters are a-z, 
	    ** 0-9, '-', '_', '%' and '\'. All unicode characters
            ** outside the ASCII range are allowed.
            */
            static u8 charmap[128] = {
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0x00-0x0F */
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0x10-0x1F */
                0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, /* 0x20-0x2F */
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, /* 0x30-0x3F */
                0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* 0x40-0x4F */
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, /* 0x50-0x5F */
                0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* 0x60-0x6F */
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0  /* 0x70-0x7F */
            };
            int i;
            for(i=0; i<n && (z[i]<0 || charmap[(int)z[i]]); i++) /* empty */ ;
            if( i==0 ) goto bad_token;
            if( i<n && z[i]=='(' ){
                int t = -1;
                int tlen;
                i++;
                while( i!=n && t!=0 && t!=CT_RRP ){
                    t = cssGetToken(&z[i], n-i, &tlen);
                    i += tlen;
                }
                if( t!=CT_RRP ) goto bad_token;
                *pLen = i;
                return CT_FUNCTION;
            }
            *pLen = i;
            return CT_IDENT;
        }
             
    }

bad_token:
    *pLen = 1;
    return -1;
}

/* Versions of HtmlAlloc() and HtmlFree() that are always functions (not macros). 
*/
static void * xCkalloc(size_t n){
    return HtmlAlloc(n);
}
static void xCkfree(void *p){
    HtmlFree(p);
}


/*
 *---------------------------------------------------------------------------
 *
 * comparePriority --
 *
 *     Compare stylesheet priorities *pLeft and *pRight, returning less
 *     than, equal to or greater than zero if *pLeft is less than, equal
 *     to, or greater than pRight. i.e the expression:
 *
 *         (*pLeft - *pRight)
 *
 *     Note that this comparison follows the rules of CSS2, not CSS1.
 *
 * Results:
 *     Result of comparison (see above).
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
#if 0
static int 
comparePriority(pLeft, pRight)
    CssPriority *pLeft;
    CssPriority *pRight;
{
    int aNormal[3] = {CSS_ORIGIN_AUTHOR, CSS_ORIGIN_USER, CSS_ORIGIN_AGENT};
    int aImportant[3] = {CSS_ORIGIN_USER, CSS_ORIGIN_AUTHOR, CSS_ORIGIN_AGENT};
    int *a = 0;

    if (pLeft->important && pRight->important) {
        a = aImportant;
    }
    if (!pLeft->important && !pRight->important) {
        a = aNormal;
    }

    /* If a is set then the 'important' flags are both set or both cleared.
     * This means we have to look at the origin (and possibly style-id)
     * values.
     */
    if (a) { 
        int i;
        if (pLeft->origin == pRight->origin) {
            CONST char *zLeft = Tcl_GetString(pLeft->pIdTail);
            CONST char *zRight = Tcl_GetString(pRight->pIdTail);
            return strcmp(zLeft, zRight);
        }
        for (i = 0; i < 3; i++) {
            if (pLeft->origin == a[i]) return 1;
            if (pRight->origin == a[i]) return -1;
        }
        assert(!"Impossible");
    }

    /* One 'important' flag is set and the other cleared. The highest
     * priority is therefore the one with the 'important' flag set.
     */
    return pLeft->important ? 1 : -1;
}
#endif

/*
 *---------------------------------------------------------------------------
 *
 * newCssPriority --
 *
 *     Add a new entry to the CssStyleSheet.pPriority list with values
 *     origin, pIdTail and important. Update the CssPriority.iPriority
 *     variable for all list members that require it.
 *
 *     See comments above CssPriority struct in cssInt.h for details.
 *
 *     The pointer to pIdList is copied and the reference count increased
 *     by one. It is decreased when the new list entry is deleted (along
 *     with the rest of the stylesheet).
 *
 * Results:
 *     Pointer to new list entry.
 *
 * Side effects:
 *     Modifies linked-list pStyle->pPriority. 
 *
 *---------------------------------------------------------------------------
 */
static CssPriority * 
newCssPriority(pStyle, origin, pIdTail, important)
    CssStyleSheet *pStyle;
    int origin;
    Tcl_Obj *pIdTail;
    int important;
{
    CssPriority *pNew;      /* New list entry */

    pNew = (CssPriority *)HtmlAlloc(sizeof(CssPriority));
    memset(pNew, 0, sizeof(CssProperty));
    pNew->origin = origin;
    pNew->important = important;
    pNew->pIdTail = pIdTail;
    Tcl_IncrRefCount(pIdTail);

    switch (origin) {
        case CSS_ORIGIN_AGENT:
            pNew->iPriority = 1;
            break;
        case CSS_ORIGIN_USER:
            if (important) {
                pNew->iPriority = 5;
            } else {
                pNew->iPriority = 2;
            }
            break;
        case CSS_ORIGIN_AUTHOR:
            if (important) {
                pNew->iPriority = 4;
            } else {
                pNew->iPriority = 3;
            }
            break;
        default:
            assert(!"Impossible");
    }

    pNew->pNext = pStyle->pPriority;
    pStyle->pPriority = pNew;

    return pNew;
}

/*
 *---------------------------------------------------------------------------
 *
 * cssParse --
 *
 *     This routine does the work of parsing stylesheets or style
 *     attributes on behalf of HtmlCssParse() and HtmlCssParseStyle()
 *     respectively. 
 * 
 *     The first two argument identify the length of, and the text to be
 *     parsed.
 *
 *     The third argument is true if z points to the text of a style
 *     attribute, i.e: "color:red ; margin:0.4em". If false, then z points
 *     to an stylesheet, i.e. "H1 {text-size: 1.2em}". The stylesheet
 *     produced when parsing a style is the same as "* {<style text>}".
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static int 
cssParse(n, z, isStyle, origin, pStyleId, pImportCmd, interp, pUrlCmd, ppStyle)
    int n;                       /* Size of z in bytes */
    CONST char *z;               /* Text of attribute/document */
    int isStyle;                 /* True if this is a style attribute */
    int origin;                  /* CSS_ORIGIN_* value */
    Tcl_Obj *pStyleId;           /* Second and later parts of stylesheet id */
    Tcl_Obj *pImportCmd;         /* Command to invoke to process @import */
    Tcl_Interp *interp;          /* Interpreter for pImportCmd (if any) */
    Tcl_Obj *pUrlCmd;            /* Command to invoke to translate url() */
    CssStyleSheet **ppStyle;     /* IN/OUT: Stylesheet to append to   */
{
    CssParse sParse;
    CssToken sToken;
    void *p;
    int t;
    int c = 0;
    int ii;

    memset(&sParse, 0, sizeof(CssParse));
    sParse.origin = origin;
    sParse.pStyleId = pStyleId;
    sParse.pImportCmd = pImportCmd;
    sParse.pUrlCmd = pUrlCmd;
    sParse.interp = interp;

    if( n<0 ){
        n = strlen(z);
    }
    p = tkhtmlCssParserAlloc(xCkalloc);

 /* tkhtmlCssParserTrace(stdout, "Parser: "); */

    /* If *ppStyle is NULL, then create a new CssStyleSheet object. If it
     * is not zero, then append the rules from the new stylesheet document
     * to the existing object.
     */
    if (0==*ppStyle) {
        sParse.pStyle = (CssStyleSheet *)HtmlAlloc(sizeof(CssStyleSheet));
        memset(sParse.pStyle, 0, sizeof(CssStyleSheet));
    } else {
        sParse.pStyle = *ppStyle;
    }

    /* If this is a stylesheet, not a style attribute, add the priority
     * entries for both regular and "!important" properties for this
     * stylesheet to the priority list.
     */
    if (pStyleId) {
        sParse.pPriority1 = newCssPriority(sParse.pStyle, origin, pStyleId, 0);
        sParse.pPriority2 = newCssPriority(sParse.pStyle, origin, pStyleId, 1);
    }

    /* If this is a style attribute, not a stylesheet, then feed the
     * parser the tokens '*' and '{' before attempting to parse the style
     * attribute text. After parsing the text, feed the parser a '}' to
     * finish everything off. Thus a style is converted to a stylesheet
     * with a rule, using the universal selector.
     */
    if (isStyle) {
         sToken.z = "*"; sToken.n = 1; 
         tkhtmlCssParser(p, CT_STAR, sToken, &sParse);
         sToken.z = "{"; sToken.n = 1; 
         tkhtmlCssParser(p, CT_LP, sToken, &sParse);
    }

    while ((t = cssGetToken(&z[c], n-c, &sToken.n))) {
        sToken.z = &z[c];
        if (t > 0) {
            tkhtmlCssParser(p, t, sToken, &sParse);
        }
        c += sToken.n;
    }

    /* if this is a style, not a stylesheet (see above), then feed the
     * closing '}' token to the parser.
     */
    if (isStyle) {
         sToken.z = "}"; sToken.n = 1; 
         tkhtmlCssParser(p, CT_RP, sToken, &sParse);
    }

    /* Pass the end-of-input token to the parser */
    sToken.z = ""; sToken.n = 0; 
    tkhtmlCssParser(p, 0, sToken, &sParse);

    *ppStyle = sParse.pStyle;
    tkhtmlCssParserFree(p, xCkfree);

    /* Clean up anything left in sParse */
    selectorFree(sParse.pSelector);
    for (ii = 0; ii < sParse.nXtra; ii++) {
        selectorFree(sParse.apXtraSelector[ii]);
    }
    propertySetFree(sParse.pPropertySet);
    propertySetFree(sParse.pImportant);

    return 0;
}

/*--------------------------------------------------------------------------
 *
 * HtmlCssParse --
 *
 *     Parse the stylesheet pointed to by z, length n bytes. See comments
 *     above cssParse() for more detail.
 *
 * Results:
 *
 *     Returns a CssStyleSheet pointer, written to *ppStyle.
 *
 * Side effects:
 *
 *--------------------------------------------------------------------------
 */
#if 0
int 
HtmlCssParse(pText, origin, pStyleId, pImportCmd, ppStyle)
    Tcl_Obj *pText;
    int origin;
    Tcl_Obj *pStyleId;
    Tcl_Obj *pImportCmd;
    CssStyleSheet **ppStyle;
{
    int n;
    CONST char *z;
    z = Tcl_GetStringFromObj(pText, &n);
    return cssParse(n, z, 0, origin, pStyleId, pImportCmd, 0, 0, ppStyle);
}
#endif

/*
 *---------------------------------------------------------------------------
 *
 * HtmlStyleParse --
 *
 *     Compile a stylesheet document from text and add it to the widget.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
int 
HtmlStyleParse(pTree, interp, pStyleText, pId, pImportCmd, pUrlCmd)
    HtmlTree *pTree;
    Tcl_Interp *interp;
    Tcl_Obj *pStyleText;
    Tcl_Obj *pId;
    Tcl_Obj *pImportCmd;
    Tcl_Obj *pUrlCmd;
{
    int origin = 0;
    Tcl_Obj *pStyleId = 0;
    CONST char *zId;
    CONST char *zStyleText;
    int nStyleText;

    /* Parse up the stylesheet id. It must begin with one of the strings
     * "agent", "user" or "author". After that it may contain any text.
     */
    zId = Tcl_GetString(pId);
    if (0==strncmp("agent", zId, 5)) {
        origin = CSS_ORIGIN_AGENT;
        pStyleId = Tcl_NewStringObj(&zId[5], -1);
    }
    else if (0==strncmp("user", zId, 4)) {
        origin = CSS_ORIGIN_USER;
        pStyleId = Tcl_NewStringObj(&zId[4], -1);
    }
    else if (0==strncmp("author", zId, 5)) {
        origin = CSS_ORIGIN_AUTHOR;
        pStyleId = Tcl_NewStringObj(&zId[6], -1);
    }
    if (!pStyleId) {
        Tcl_AppendResult(interp, "Bad style-sheet-id: ", zId, 0);
        return TCL_ERROR;
    }
    Tcl_IncrRefCount(pStyleId);

    /* If there is already a stylesheet in pTree->pStyle, then this call will
     * parse the stylesheet text in pStyleText and append rules to the
     * existing stylesheet. If pTree->pStyle is NULL, then a new stylesheet is
     * created. Within Tkhtml, each document only ever has a single stylesheet
     * object, possibly created by combining text from multiple stylesheet
     * documents.
     */
    zStyleText = Tcl_GetStringFromObj(pStyleText, &nStyleText);
    cssParse(
        nStyleText, zStyleText,            /* Stylesheet text */
        0,                                 /* This is not a style attribute */
        origin,                            /* Origin - CSS_ORIGIN_XXX */
        pStyleId,                          /* Rest of -id option */
        pImportCmd, pTree->interp,         /* How to handle @import */
        pUrlCmd,                           /* How to handle url() */
        &pTree->pStyle                     /* CssStylesheet to update/create */
    );

    Tcl_DecrRefCount(pStyleId);
    return TCL_OK;
}

/*--------------------------------------------------------------------------
 *
 * HtmlCssParseStyle --
 *
 *     Parse the style attribute value pointed to by z, length n bytes. See
 *     comments above cssParse() for more detail.
 *
 * Results:
 *
 *     Returns a CssStyleSheet pointer, written to *ppStyle.
 *
 * Side effects:
 *
 *--------------------------------------------------------------------------
 */
int HtmlCssParseStyle(
    int n,
    const char *z,
    CssProperties **ppProperties
){
    CssStyleSheet *pStyle = 0;
    assert(ppProperties && !(*ppProperties));
    cssParse(n, z, 1, 0, 0, 0, 0, 0,&pStyle);
    if (pStyle) {
        if (pStyle->pUniversalRules) {
            assert(!pStyle->pUniversalRules->pNext);
            propertiesAdd(ppProperties, pStyle->pUniversalRules);
            pStyle->pUniversalRules = 0;
        }
        assert(!pStyle->pPriority);
        HtmlCssStyleSheetFree(pStyle);
    }
    return 0;
}

/*
 *---------------------------------------------------------------------------
 *
 * ruleFree --
 *
 *     Free the CssRule object pRule.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static void 
ruleFree(pRule)
    CssRule *pRule;
{
    if (pRule) {
        if (pRule->freeSelector) {
            selectorFree(pRule->pSelector);
        }
        if (pRule->freePropertySets) {
            propertySetFree(pRule->pPropertySet);
        }
        HtmlFree((char *)pRule);
    }
}

/*
 *---------------------------------------------------------------------------
 *
 * HtmlCssStyleSheetFree --
 *
 *     Delete the internal representation of the stylesheet configuration.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
void 
HtmlCssStyleSheetFree(pStyle)
    CssStyleSheet *pStyle;
{
    if (pStyle) {
        CssPriority *pPriority;
        CssRule *pRule;

        pRule = pStyle->pUniversalRules; 
        while (pRule) { 
            CssRule *pNext = pRule->pNext;
            ruleFree(pRule);
            pRule = pNext;
        }

        pPriority = pStyle->pPriority;
        while (pPriority) {
            CssPriority *pNext = pPriority->pNext;
            Tcl_DecrRefCount(pPriority->pIdTail);
            HtmlFree((char *)pPriority);
            pPriority = pNext;
        }

        HtmlFree((char *)pStyle);
    }
}

/*
** Return the number of syntax errors that occured while parsing the
** style-sheet.
*/
int HtmlCssStyleSheetSyntaxErrs(CssStyleSheet *pStyle){
    return pStyle->nSyntaxErr;
}

/*--------------------------------------------------------------------------
 *
 * HtmlCssDeclaration --
 *
 *     This function is called by the CSS parser when it parses a property 
 *     declaration (i.e "<property> : <expression>").
 *
 * Results:
 *     None.
 *
 * Side effects:
 *
 *--------------------------------------------------------------------------
 */
void
HtmlCssDeclaration(pParse, pProp, pExpr, isImportant)
    CssParse *pParse;
    CssToken *pProp;
    CssToken *pExpr;
    int isImportant;         /* True if the !IMPORTANT symbol was seen */
{
    int prop; 
    CssPropertySet **ppPropertySet;

    /* Do nothing if the isIgnore flag is set */
    if (pParse->isIgnore) return;

#if TRACE_PARSER_CALLS
    printf("HtmlCssDeclaration(%p, \"%.*s\", \"%.*s\")\n", 
        pParse,
        pProp?pProp->n:0, pProp?pProp->z:"", 
        pExpr?pExpr->n:0, pExpr?pExpr->z:""
    );
#endif

    /* Resolve the property name. If we don't recognize it, then ignore the
     * declaration (CSS2 spec says to do this - besides, what else could we
     * do?).
     */
    prop = HtmlCssPropertyLookup(pProp->n, pProp->z);
    if( prop<0 ) return;

    if (isImportant) {
        ppPropertySet = &pParse->pImportant;
    } else {
        ppPropertySet = &pParse->pPropertySet;
    }
    if( !*ppPropertySet ){
        *ppPropertySet = propertySetNew();
    }

    switch (prop) {
        case CSS_SHORTCUTPROPERTY_BORDER:
        case CSS_SHORTCUTPROPERTY_BORDER_LEFT:
        case CSS_SHORTCUTPROPERTY_BORDER_RIGHT:
        case CSS_SHORTCUTPROPERTY_BORDER_TOP:
        case CSS_SHORTCUTPROPERTY_BORDER_BOTTOM:
            propertySetAddShortcutBorder(*ppPropertySet, prop, pExpr);
            break;
        case CSS_SHORTCUTPROPERTY_BORDER_COLOR:
        case CSS_SHORTCUTPROPERTY_BORDER_STYLE:
        case CSS_SHORTCUTPROPERTY_BORDER_WIDTH:
        case CSS_SHORTCUTPROPERTY_PADDING:
        case CSS_SHORTCUTPROPERTY_MARGIN:
            propertySetAddShortcutBorderColor(*ppPropertySet, prop, pExpr);
            break;
        case CSS_SHORTCUTPROPERTY_BACKGROUND:
            shortcutBackground(pParse, *ppPropertySet, pExpr);
            break;
        case CSS_SHORTCUTPROPERTY_BACKGROUND_POSITION:
            propertySetAddShortcutBackgroundPosition(*ppPropertySet, pExpr);
            break;
        case CSS_SHORTCUTPROPERTY_FONT:
            propertySetAddShortcutFont(*ppPropertySet, pExpr);
            break;
        case CSS_SHORTCUTPROPERTY_LIST_STYLE:
            shortcutListStyle(pParse, *ppPropertySet, pExpr);
            break;
        default:
            propertySetAdd(*ppPropertySet, prop, tokenToProperty(pParse,pExpr));
    }
}



/*--------------------------------------------------------------------------
 *
 * HtmlCssSelector --
 *
 *     This is called whenever a simple selector is parsed. 
 *     i.e. "H1" or ":before".
 *
 *     A CssSelector struct is allocated and added to the beginning of the
 *     linked list at pParse->pSelector;
 *
 * Results:
 *     None.
 *
 * Side effects:
 *
 *--------------------------------------------------------------------------
 */
void HtmlCssSelector(pParse, stype, pAttr, pValue)
    CssParse *pParse; 
    int stype; 
    CssToken *pAttr; 
    CssToken *pValue;
{
    CssSelector *pSelector;

    /* Do nothing if the isIgnore flag is set */
    if (pParse->isIgnore) return;

#if TRACE_PARSER_CALLS
    /* I used this to make sure the parser was passing the components of
     * selectors to this function in the correct order. Once this was 
     * verified, it is not particularly useful trace output. But we'll leave
     * it here for the time being in case something comes up.
     */
    printf("HtmlCssSelector(%p, %s, \"%.*s\", \"%.*s\")\n", 
        pParse, constantToString(stype), 
        pAttr?pAttr->n:0, pAttr?pAttr->z:"", 
        pValue?pValue->n:0, pValue?pValue->z:""
    );
#endif

    pSelector = (CssSelector *)HtmlAlloc(sizeof(CssSelector));
    memset(pSelector, 0, sizeof(CssSelector));
    pSelector->eSelector = stype;
    pSelector->zValue = tokenToString(pValue);
    dequote(pSelector->zValue);
    pSelector->zAttr = tokenToString(pAttr);
    pSelector->pNext = pParse->pSelector;
    pParse->pSelector = pSelector;

    /* Tag names are case-insensitive - fold to lower case */
    if( stype==CSS_SELECTOR_TYPE ){
        assert(pSelector->zValue);
        Tcl_UtfToLower(pSelector->zValue);
    }
}

/*
 *---------------------------------------------------------------------------
 *
 * ruleCompare --
 *
 *     Compare the priority of two rule objects. Return greater than zero
 *     if the priority of pLeft is higher, zero if the two rules have the
 *     same priority, and negative if pRight has higher priority. i.e.:
 *
 *         PRIORITY(pLeft) - PRIORITY(pRight)
 *
 *     This function is used to determine the order of rules in the
 *     rules CssRule.pNext linked list.
 *
 * Results:
 *     See above.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static int 
ruleCompare(CssRule *pLeft, CssRule *pRight) {
    int res = 0;

    assert(pLeft && pRight);
    assert(pRight->pPriority);
    assert(pLeft->pPriority);

    res = pLeft->pPriority->iPriority - pRight->pPriority->iPriority;

    if (res == 0) {
        /* But here we want (left - right), because specificity is higher
         * for more specific rules.
         */
        res = pLeft->specificity - pRight->specificity;

        if (res == 0) {
            CONST char *zLeft = Tcl_GetString(pLeft->pPriority->pIdTail);
            CONST char *zRight = Tcl_GetString(pLeft->pPriority->pIdTail);
            res = strcmp(zLeft, zRight);
        }
    }
    return res;
}

/*
 *---------------------------------------------------------------------------
 *
 * cssSelectorPropertySetPair --
 *
 *     A rule has just been parsed with selector pSelector and properties
 *     pPropertySet. This function creates a CssRule object to link the two
 *     together and inserts the new rule into the CssStyleSheet structure.
 *
 *     The caller should not free resources associated with pSelector or
 *     pPropertySet after this function returns, they are now linked into
 *     the stylesheet object.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
#define FREE_SELECTOR    0x00000001
#define FREE_PROPERTYSET 0x00000002
#define FREE_BOTH        0x00000003
static void 
cssSelectorPropertySetPair(pParse, pSelector, pPropertySet, freeWhat)
    CssParse *pParse;
    CssSelector *pSelector;
    CssPropertySet *pPropertySet;
    unsigned int freeWhat;
{
    int spec = 0;
    CssSelector *pS = 0;
    CssStyleSheet *pStyle = pParse->pStyle;
    CssRule *pRule = (CssRule *)HtmlAlloc(sizeof(CssRule));
    memset(pRule, 0, sizeof(CssRule));

    assert(pPropertySet && pPropertySet->n > 0);

    if (freeWhat & FREE_PROPERTYSET) {
        pRule->freePropertySets = 1;
    }
    if (freeWhat & FREE_SELECTOR) {
        pRule->freeSelector = 1;
    }

    /* Calculate the specificity of the rules. We use the following
     * formala:
     *
     *     Specificity = (number of id selectors)        * 10000 +
     *                   (number of attribute selectors) * 100   +
     *                   (number of pseudo classes)      * 100   +
     *                   (number of type selectors)
     *
     * Todo: There are (at least) two bugs here:
     *     1. A rule with 100 type selectors has greater specificity than a
     *        rule with a single attribute selector. This probably isn't a
     *        problem.
     *     2. A selector of the form '[id="hello"]' has the same
     *        specificity as the selector '.hello'. This is pretty obscure,
     *        but could come up.
     * 
     * See section 6.4, "The cascade", of CSS2 documentation for details on
     * selector specificity.
     */
    for (pS=pSelector; pS; pS = pS->pNext) {
         switch (pS->eSelector) {
             case CSS_SELECTOR_TYPE:
                 spec += 1;
                 break;
             case CSS_SELECTOR_ATTR:
             case CSS_SELECTOR_ATTRVALUE:
             case CSS_SELECTOR_ATTRLISTVALUE:
             case CSS_SELECTOR_ATTRHYPHEN:
                 if (0==strcmp(pS->zAttr, "id")) {
                     spec += 10000;
                     break;
                 }
             case CSS_PSEUDOCLASS_LANG:
             case CSS_PSEUDOCLASS_FIRSTCHILD:
             case CSS_PSEUDOCLASS_LINK:
             case CSS_PSEUDOCLASS_VISITED:
             case CSS_PSEUDOCLASS_ACTIVE:
             case CSS_PSEUDOCLASS_HOVER:
             case CSS_PSEUDOCLASS_FOCUS:
                 spec += 100;
                 break;
         }
    }
    pRule->specificity = spec;
    assert(
        pPropertySet == pParse->pPropertySet || 
        pPropertySet == pParse->pImportant
    );
    if (pParse->pPropertySet == pPropertySet) {
        pRule->pPriority = pParse->pPriority1;
    } else {
        pRule->pPriority = pParse->pPriority2;
    }

    if( 0 && pSelector->eSelector==CSS_SELECTOR_TYPE ){
#if 0
        Tcl_HashEntry *pEntry; 
        int n;         /* True if we add a a new hash table entry */
        assert( pSelector->zValue );
        pEntry = Tcl_CreateHashEntry(&pStyle->rules, pSelector->zValue, &n);
        pRule->pNext = Tcl_GetHashValue(pEntry);
        assert( (n && !pRule->pNext) || (!n && pRule->pNext) );
        Tcl_SetHashValue(pEntry, pRule);
#endif
    }else{
        /* The rule doesn't belong in any hash table, so put it in the
         * default list.
         */
        CssRule *pR = pStyle->pUniversalRules;

        if (!pR || ruleCompare(pR, pRule)<=0) {
            /* If the default list is currently empty, or the rule being
	     * added has higher priority than the first rule in the list,
             * our rule becomes the new head of the list.
             */
	    pRule->pNext = pStyle->pUniversalRules;
            pStyle->pUniversalRules = pRule;
        } else {
            /* Otherwise insert the new rule into the list, ordered by
             * priority. If there exists another rule with the same
             * priority, then this rule is inserted into the list *before*
             * it. This is because when rules are of equal priority, the
             * latter specified wins.
             */
            while (pR->pNext && ruleCompare(pR->pNext, pRule)>0 ) {
                pR = pR->pNext;
            }
            pRule->pNext = pR->pNext;
            pR->pNext = pRule;
        }
    }

    pRule->pSelector = pSelector;
    pRule->pPropertySet = pPropertySet;
}

int HtmlCssPseudo(pToken)
    CssToken *pToken;
{
    char *zOptions[] = {"link", "visited"};
    int eOptions[] = {CSS_PSEUDOCLASS_LINK, CSS_PSEUDOCLASS_VISITED};
    int i;

    for (i=0; i<sizeof(zOptions)/sizeof(char *); i++) {
        if (pToken->n==strlen(zOptions[i]) && 
                0==strncmp(pToken->z, zOptions[i], pToken->n)) {
            return eOptions[i];
        }
    }
    return CSS_PSEUDOCLASS_LANG;
}

/*--------------------------------------------------------------------------
 *
 * HtmlCssRule --
 *
 *     This is called when the parser has parsed an entire rule.
 *
 * Results:
 *     None.
 *
 * Side effects:
 * 
 *     If the parse was successful, then add the rule to the stylesheet.
 *     If unsuccessful, delete anything that was built up by calls to 
 *     HtmlCssDeclaration() or HtmlCssSelector().
 *
 *--------------------------------------------------------------------------
 */
void HtmlCssRule(pParse, success)
    CssParse *pParse;
    int success;
{
    CssSelector *pSelector = pParse->pSelector;
    CssPropertySet *pPropertySet = pParse->pPropertySet;
    CssPropertySet *pImportant = pParse->pImportant;
    CssSelector **apXtraSelector = pParse->apXtraSelector;
    int nXtra = pParse->nXtra;
    int i;

    /* Do nothing if the isIgnore flag is set */
    if (pParse->isIgnore) return;

    if (pPropertySet && pPropertySet->n == 0) {
        propertySetFree(pPropertySet);
        pPropertySet = 0;
    }
    if (pImportant && pImportant->n == 0) {
        propertySetFree(pImportant);
        pImportant = 0;
    }

    if (success && pSelector && (pPropertySet || pImportant)) {

        if (pPropertySet) {
            unsigned int flags = FREE_BOTH;
            cssSelectorPropertySetPair(pParse, pSelector, pPropertySet, flags);
            for (i = 0; i < nXtra; i++){
                unsigned int flags2 = FREE_SELECTOR;
                CssSelector *pS = apXtraSelector[i];
                cssSelectorPropertySetPair(pParse, pS, pPropertySet, flags2);
            }
        }

        if (pImportant) {
            unsigned int flags = (pPropertySet ? FREE_PROPERTYSET : FREE_BOTH);
            cssSelectorPropertySetPair(pParse, pSelector, pImportant, flags);
            for (i = 0; i < nXtra; i++){
                unsigned int flags2 = (pPropertySet ? 0 : FREE_SELECTOR);
                CssSelector *pS = apXtraSelector[i];
                cssSelectorPropertySetPair(pParse, pS, pImportant, flags2);
            }
        }

    }else{
        /* Some sort of a parse error has occured. We won't be including
         * this rule, so just free these structs so we don't leak memory.
         */ 
        selectorFree(pSelector);
        propertySetFree(pPropertySet);
        propertySetFree(pImportant);
        for (i = 0; i < nXtra; i++){
            selectorFree(apXtraSelector[i]);
        }
    }

    pParse->pSelector = 0;
    pParse->pPropertySet = 0;
    pParse->pImportant = 0;
    pParse->apXtraSelector = 0;
    pParse->nXtra = 0;

    if( apXtraSelector ){
        HtmlFree((char *)apXtraSelector);
    }
}

/*--------------------------------------------------------------------------
 *
 * attrTest --
 *
 *     Test if an attribute value matches a string. The three modes of 
 *     comparing attribute values specified in CSS are supported.
 *
 * Results:
 *     Non-zero is returned if the match is true.
 *
 * Side effects:
 *     None.
 *
 *--------------------------------------------------------------------------
 */
static int attrTest(eType, zString, zAttr)
    u8 eType;
    const char *zString;
    const char *zAttr;
{
    if (!zAttr) {
        return 0;
    }

    switch( eType ){
        /* True if the specified attribute exists */
        case CSS_SELECTOR_ATTR:
            return (zAttr?1:0);

        /* True if the specified attribute exists and the value matches
         * the string exactly.
         */
        case CSS_SELECTOR_ATTRVALUE:
            return ((zAttr && 0==stricmp(zAttr, zString))?1:0);

	/* Treat the attribute value (if it exists) as a space seperated list.
         * Return true if zString exists in the list.
         */
        case CSS_SELECTOR_ATTRLISTVALUE: {
            const char *pAttr = zAttr;
            int nAttr;
            int nString = strlen(zString);
            while ((pAttr=getNextListItem(pAttr, strlen(pAttr), &nAttr))) {
                if (nString==nAttr && 0==strncasecmp(pAttr, zString, nAttr)) {
                    return 1;
                }
                pAttr += nAttr;
            }
            return 0;
        }

        /* True if the attribute exists and matches zString up to the
         * first '-' character in the attribute value.
         */
        case CSS_SELECTOR_ATTRHYPHEN: {
            char *pHyphen = strchr(zAttr, '-');
            if( pHyphen && 0==strncasecmp(zAttr, zString, pHyphen-zAttr) ){
                return 1;
            }
            return 0;
        }
    }

    assert(!"Impossible");
    return 0;
}

/*--------------------------------------------------------------------------
 *
 * selectorTest --
 *
 *     Test if a selector matches a document node.
 *
 * Results:
 *     Non-zero is returned if the Selector does match the node.
 *
 * Side effects:
 *     None.
 *
 *--------------------------------------------------------------------------
 */
#define N_TYPE(x)        HtmlNodeTagName(x)
#define N_ATTR(x,y)      HtmlNodeAttr(x,y)
#define N_PARENT(x)      HtmlNodeParent(x)
#define N_NUMCHILDREN(x) HtmlNodeNumChildren(x)
#define N_CHILD(x,y)     HtmlNodeChild(x,y)
static int 
selectorTest(pSelector, pNode)
    CssSelector *pSelector;
    HtmlNode *pNode;
{
    CssSelector *p = pSelector;
    HtmlNode *x = pNode;
    while( p && x ){

        switch( p->eSelector ){
            case CSS_SELECTOR_UNIVERSAL:
                break;

            case CSS_SELECTOR_TYPE:
                if( strcmp(N_TYPE(x), p->zValue) ) return 0;
                break;

            case CSS_SELECTOR_ATTR:
            case CSS_SELECTOR_ATTRVALUE:
            case CSS_SELECTOR_ATTRLISTVALUE:
            case CSS_SELECTOR_ATTRHYPHEN:
                if( !attrTest(p->eSelector, p->zValue, N_ATTR(x,p->zAttr)) ){
                    return 0;
                }
                break;

            case CSS_SELECTORCHAIN_DESCENDANT: {
                HtmlNode *pParent = N_PARENT(x);
                CssSelector *pNext = p->pNext;
                while (pParent) {
                    if (selectorTest(pNext, pParent)) {
                        return 1;
                    }
                    pParent = N_PARENT(pParent);
                }
                return 0;
            }
            case CSS_SELECTORCHAIN_CHILD:
                x = N_PARENT(x);
                break;
            case CSS_SELECTORCHAIN_ADJACENT: {
                HtmlNode *pParent = N_PARENT(x);
                int i;
                for (i = 0; N_CHILD(pParent, i) != x; i++);
                if (i==0)  {
                    return 0;
                }
                x = N_CHILD(N_PARENT(x), i-1);
                break;
            }
                
            /* TODO: Support pseudo elements and classes properly. The
             * really important ones are ":visited" and ":link". ":active",
             * ":hover" and ":focus" are also pretty crucial to rendering
             * the web correctly.
             */
            case CSS_PSEUDOCLASS_LANG:
            case CSS_PSEUDOCLASS_FIRSTCHILD:
                return 0;
            case CSS_PSEUDOCLASS_LINK:
                /* Psuedo-class ":link". This rule matches any element with
                 * tag-type <a> and an href attribute.
                 */
                if (strcmp(N_TYPE(x), "a") ||
                    !attrTest(CSS_SELECTOR_ATTR, 0, N_ATTR(x,"href"))
                ) {
                    return 0;
                }
                break;
            case CSS_PSEUDOCLASS_VISITED:
            case CSS_PSEUDOCLASS_ACTIVE:
            case CSS_PSEUDOCLASS_HOVER:
            case CSS_PSEUDOCLASS_FOCUS:
            case CSS_PSEUDOELEMENT_FIRSTLINE:
            case CSS_PSEUDOELEMENT_FIRSTLETTER:
            case CSS_PSEUDOELEMENT_BEFORE:
            case CSS_PSEUDOELEMENT_AFTER:
                return 0;

            case CSS_SELECTOR_NEVERMATCH:
                return 0;

            default:
                assert(!"Impossible");
        }
        p = p->pNext;
    }

    return (x && !p)?1:0;
}

static void propertiesAdd(ppProperties, pRule)
    CssProperties **ppProperties;
    CssRule *pRule;
{
    CssProperties *pProperties = *ppProperties;
    int n = (pProperties?pProperties->nRule:0) + 1;
    int nAlloc = sizeof(CssProperties) + n*sizeof(CssRule *);

    assert( pRule );

    pProperties = (CssProperties *)HtmlRealloc((char *)pProperties, nAlloc);
    pProperties->nRule = n;
    pProperties->apRule = (CssRule **)&pProperties[1];
    pProperties->apRule[n-1] = pRule;

    *ppProperties = pProperties;
}

void HtmlCssPropertiesFree(pPropertySet)
    CssProperties *pPropertySet;
{
    if (pPropertySet) {
        int i;
        for (i = 0; i < pPropertySet->nRule; i++) {
            ruleFree(pPropertySet->apRule[i]);
        }
        HtmlFree((char *)pPropertySet);
    }
}

/*
 *---------------------------------------------------------------------------
 *
 * ruleToPropertyValues --
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static void 
ruleToPropertyValues(p, aPropDone, pRule)
    HtmlComputedValuesCreator *p;
    int *aPropDone;
    CssRule *pRule;
{
    CssPropertySet *pSet = pRule->pPropertySet;
    int i;

    assert(pSet);

    for (i = 0; i < pSet->n; i++) {
        int eProp = pSet->a[i].eProp;
	/* eProp may be greater than MAX_PROPERTY if it stores a composite
	 * property that Tkhtml doesn't handle. In this case just ignore it.
         */
	if (eProp <= CSS_PROPERTY_MAX_PROPERTY && 0 == aPropDone[eProp]) {
            if (0 == HtmlComputedValuesSet(p, eProp, pSet->a[i].pProp)) {
                aPropDone[eProp] = 1;
            }
        }
    }
}

/*--------------------------------------------------------------------------
 *
 * HtmlCssStyleSheetApply --
 *
 *     Argument pStyle contains the current stylesheet configuration for the
 *     document. It is assumed that pNode->pStyle contains the stylesheet
 *     parsed from any HTML style attribute attached to the node and that the
 *     nodes property cache has been allocated but not yet populated. Once this
 *     function returns, the property-cache of pNode is filled in with the
 *     styler output for the node.
 *
 * Results:
 *
 *     None.
 *
 * Side effects:
 *
 *--------------------------------------------------------------------------
 */
void 
HtmlCssStyleSheetApply(pTree, pNode)
    HtmlTree *pTree; 
    HtmlNode *pNode; 
{
    CssStyleSheet *pStyle = pTree->pStyle;    /* Stylesheet config */
    CssRule *pRule;                           /* Iterator variable */
    int style_done = 0;      /* Set after considering the html "style" attr */

    HtmlComputedValuesCreator sCreator;

    /* The array aPropDone is large enough to contain an entry for each
     * property recognized by the CSS parser (approx 110, includes many that
     * Tkhtml does not use). After a property value is successfully written
     * into sCreator, the matching aPropDone entry is set to true.
     */
    int aPropDone[CSS_PROPERTY_MAX_PROPERTY + 1];

    /* Initialise aPropDone and sCreator */
    HtmlComputedValuesInit(pTree, pNode, &sCreator);
    memset(aPropDone, 0, sizeof(aPropDone));
    assert(sizeof(aPropDone) == sizeof(int) * (CSS_PROPERTY_MAX_PROPERTY+1));

    /* Loop through the list of CSS rules in the stylesheet. Rules that occur
     * earlier in the list have a higher priority than those that occur later.
     */
    for (pRule = pStyle->pUniversalRules; pRule; pRule = pRule->pNext) {
        CssPriority *pPriority = pRule->pPriority;

        /* If this rule is not "!important", and is on either the user or
         * agent stylesheet, or has a specificity of less than or equal to
         * a single "id" selector, then the "style" attribute should be
         * considered before it.
         */
        if (!style_done && 
            !pPriority->important &&
            (pPriority->origin != CSS_ORIGIN_AUTHOR ||
             pRule->specificity <= 10000)
        ) {
            style_done = 1;
            if (pNode->pStyle) {
                CssRule *pRule2 = pNode->pStyle->apRule[0];
                assert(pNode->pStyle->nRule == 1);
                ruleToPropertyValues(&sCreator, aPropDone, pRule2);
            }
        }

        /* If the selector is a match for our node, apply the rule properties */
        if (selectorTest(pRule->pSelector, pNode)) {
            ruleToPropertyValues(&sCreator, aPropDone, pRule);
        }
    }

    if (!style_done && pNode->pStyle) {
        assert(pNode->pStyle->nRule == 1);
        ruleToPropertyValues(&sCreator, aPropDone, pNode->pStyle->apRule[0]);
    }

    /* Call HtmlComputedValuesFinish() to finish creating teh
     * HtmlComputedValues structure.
     */
    pNode->pPropertyValues = HtmlComputedValuesFinish(&sCreator);
}

/*--------------------------------------------------------------------------
 *
 * HtmlCssPropertiesGet --
 *     Retrieve the value of a specified property from a CssProperties
 *     object, or NULL if the property is not defined.
 *
 * Results:
 *
 * Side effects:
 *
 *--------------------------------------------------------------------------
 */
CssProperty *
HtmlCssPropertiesGet(pProperties, prop, pSheetnum, pSpec)
    CssProperties * pProperties; 
    int prop;
    int *pSheetnum;
    int *pSpec;
{
    CssProperty *zRet = 0;
    if (pProperties) {
        int i;
        for (i=0; i<pProperties->nRule && !zRet; i++){
            CssPropertySet *pPropertySet = pProperties->apRule[i]->pPropertySet;
            zRet = propertySetGet(pPropertySet, prop);
            if (zRet) {
                if (pSheetnum)  {
                    *pSheetnum = pProperties->apRule[i]->pPriority->origin;
                }
                if (pSpec) {
                    *pSpec = pProperties->apRule[i]->specificity;
                }
            }
        }
    }
    return zRet;
}

/*
 *---------------------------------------------------------------------------
 *
 * HtmlCssSelectorComma --
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
void HtmlCssSelectorComma(pParse)
    CssParse *pParse;
{
    int n = (pParse->nXtra + 1) * sizeof(CssSelector *);

    /* Do nothing if the isIgnore flag is set */
    if (pParse->isIgnore) return;

    pParse->apXtraSelector = 
       (CssSelector **)HtmlRealloc((char *)pParse->apXtraSelector, n);
    pParse->apXtraSelector[pParse->nXtra] = pParse->pSelector;
    pParse->pSelector = 0;
    pParse->nXtra++;
}

/*
 *---------------------------------------------------------------------------
 *
 * HtmlCssImport --
 *
 *     The parser calls this function when an @import directive is encountered.
 *     The pToken argument contains the specified URL.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     May invoke the -importcmd script.
 *
 *---------------------------------------------------------------------------
 */
void HtmlCssImport(pParse, pToken)
    CssParse *pParse;
    CssToken *pToken;
{
    Tcl_Obj *pEval = pParse->pImportCmd;

    /* Do nothing if the isIgnore flag is set */
    if (pParse->isIgnore) return;

    if (pEval) {
        Tcl_Interp *interp = pParse->interp;
        CssProperty *p = tokenToProperty(pParse, pToken);
        CONST char *zUrl = p->v.zVal;

        switch (p->eType) {
            case CSS_TYPE_URL:
                break;
            case CSS_TYPE_STRING:
                if (pParse && pParse->pUrlCmd) {
                    doUrlCmd(pParse, zUrl, strlen(zUrl));
                    zUrl = Tcl_GetStringResult(pParse->interp);
                }
                break;
            default:
                return;
        }

        pEval = Tcl_DuplicateObj(pEval);
        Tcl_IncrRefCount(pEval);
        Tcl_ListObjAppendElement(interp, pEval, Tcl_NewStringObj(zUrl, -1));
        Tcl_EvalObjEx(interp, pEval, TCL_EVAL_GLOBAL|TCL_EVAL_DIRECT);
        Tcl_DecrRefCount(pEval);
        HtmlFree((char *)p);
    }
}

struct CssSearch {
  CssSelector *pSelector;
  Tcl_Obj *pResult;
  HtmlTree *pTree;
};
typedef struct CssSearch CssSearch;

static int 
cssSearchCallback(pTree, pNode, clientData)
    HtmlTree *pTree; 
    HtmlNode *pNode;
    ClientData clientData;
{
    CssSearch *pSearch = (CssSearch *)clientData;
    assert(pSearch->pSelector);
    assert(pSearch->pResult);
    if (selectorTest(pSearch->pSelector, pNode)) {
        Tcl_Obj *pCmd = HtmlNodeCommand(pSearch->pTree, pNode);
        Tcl_ListObjAppendElement(0, pSearch->pResult, pCmd);
    }
    return 0;
}

/*
 *---------------------------------------------------------------------------
 *
 * HtmlCssSearch --
 *
 *     widget search CSS-SELECTOR
 *
 * Results:
 *     None.
 *
 * Side effects:
 *
 *---------------------------------------------------------------------------
 */
int 
HtmlCssSearch(clientData, interp, objc, objv)
    ClientData clientData;             /* The HTML widget */
    Tcl_Interp *interp;                /* The interpreter */
    int objc;                          /* Number of arguments */
    Tcl_Obj *CONST objv[];             /* List of all arguments */
{
    HtmlTree *pTree = (HtmlTree *)clientData;
    char *zOrig;
    char *z;
    int n;
    int rc = TCL_OK;
    CssStyleSheet *pStyle = 0;

    if (objc != 3) {
        Tcl_WrongNumArgs(interp, 2, objv, "CSS-SELECTOR");
        return TCL_ERROR;
    }

    zOrig = Tcl_GetStringFromObj(objv[2], &n);
    assert(n == strlen(zOrig));
    n += 14;
    z = (char *)HtmlAlloc(n);
    sprintf(z, "%s {color:blue}", zOrig);

    cssParse(n, z, 0, 0, 0, 0, 0, 0,&pStyle);
    if (
        !pStyle || 
        !pStyle->pUniversalRules || 
        pStyle->pUniversalRules->pNext
    ) {
        rc = TCL_ERROR;
        Tcl_AppendResult(interp, "Bad css selector: \"", zOrig, "\"", 0); 
    } else {
        CssSelector *pSelector = pStyle->pUniversalRules->pSelector;
        CssSearch sSearch;
        Tcl_Obj *pObj = Tcl_NewObj();
        sSearch.pSelector = pSelector;
        sSearch.pResult = pObj;
        sSearch.pTree = pTree;
        HtmlWalkTree(pTree, cssSearchCallback, (ClientData)&sSearch);

        Tcl_SetObjResult(interp, pObj);
    }

    HtmlCssStyleSheetFree(pStyle);
    HtmlFree(z);
    return rc;
}


