/* Display types for non-table items. */
  ADDRESS, BLOCKQUOTE, BODY, DD, DIV, DL, DT, FIELDSET, FORM,
  FRAME, FRAMESET, H1, H2, H3, H4, H5, H6, IFRAME, NOFRAMES, 
  OBJECT, OL, P, UL, APPLET, CENTER, DIR, HR, MENU, PRE
                { display: block }
HEAD, SCRIPT    { display: none }

BODY            { 
    padding-top: 8px; 
    padding-bottom:8px; 
    padding-left:8px;
    padding-right:8px;
    line-height: 1.33; 
    background-color: white;
}

HTML {
    background-color: white;
}

/* Rules for unordered-lists */
LI                   { display: list-item }
UL[type="square"]>LI { list-style-type : square } 
UL[type="disc"]>LI   { list-style-type : disc   } 
UL[type="circle"]>LI { list-style-type : circle } 
LI[type="circle"]    { list-style-type : circle }
LI[type="square"]    { list-style-type : square }
LI[type="disc"]      { list-style-type : disc   }

OL, UL, DIR, MENU, DD  { padding-left: 40px ; margin-left: 1em }


/* Map the 'align' attribute to the 'float' property. Todo: This should
 * only be done for images, tables etc. "align" can mean different things
 * for different elements.
 */
TABLE[align="left"]       { float:left } 
TABLE[align="right"]      { float:right }
IMG[align="left"]         { float:left }
IMG[align="right"]        { float:right }

/* If the 'align' attribute was not mapped to float by the rules above, map
 * it to 'text-align'. The rules above take precedence because of their
 * higher specificity. 
 *
 * Also the <center> tag means to center align things.
 */
[align="center"]  { text-align:center }
[align="right"]   { text-align:right }
[align="left"]    { text-align:left }
CENTER            { text-align: center }
TABLE             { text-align: left }


/* Rules for unordered-lists */
/* Todo! */

TD, TH {
  padding: 1px;
  border-bottom-color: grey60;
  border-right-color: grey60;
  border-top-color: grey25;
  border-left-color: grey25;
}

/* For a horizontal line, use a table with no content. We use a table
 * instead of a block because tables are laid out around floating boxes, 
 * whereas regular blocks are not.
 */
HR { 
  display: table; 
  border-top: 1px solid grey45;
  background: grey80;
  height: 1px;
  width: 100%;
  text-align: center;
  margin: 0.5em 0;
}

/* Basic table tag rules. */
TABLE { 
  display: table;
  border-spacing: 2px;

  border-bottom-color: grey25;
  border-right-color: grey25;
  border-top-color: grey60;
  border-left-color: grey60;
}

TR              { display: table-row }
THEAD           { display: table-header-group }
TBODY           { display: table-row-group }
TFOOT           { display: table-footer-group }
COL             { display: table-column }
COLGROUP        { display: table-column-group }
TD, TH          { display: table-cell }
CAPTION         { display: table-caption }
TH              { font-weight: bolder; text-align: center }
CAPTION         { text-align: center }

H1              { font-size: 2em; margin: .67em 0 }
H2              { font-size: 1.5em; margin: .83em 0 }
H3              { font-size: 1.17em; margin: 1em 0 }
H4, P,
BLOCKQUOTE, UL,
FIELDSET, FORM,
OL, DL, DIR,
MENU            { margin-top: 1.0em; margin-bottom: 1.0em }
H5              { font-size: .83em; line-height: 1.17em; margin: 1.67em 0 }
H6              { font-size: .67em; margin: 2.33em 0 }
H1, H2, H3, H4,
H5, H6, B,
STRONG          { font-weight: bolder }
BLOCKQUOTE      { margin-left: 40px; margin-right: 40px }
I, CITE, EM,
VAR, ADDRESS    { font-style: italic }
PRE, TT, CODE,
KBD, SAMP       { font-family: courier }
BIG             { font-size: 1.17em }
SMALL, SUB, SUP { font-size: .83em }
SUB             { vertical-align: sub }
SUP             { vertical-align: super }
S, STRIKE, DEL  { text-decoration: line-through }
OL              { list-style-type: decimal }
OL UL, UL OL,
UL UL, OL OL    { margin-top: 0; margin-bottom: 0 }
U, INS          { text-decoration: underline }
ABBR, ACRONYM   { font-variant: small-caps; letter-spacing: 0.1em }

/* Formatting for <pre> etc. */
PRE, PLAINTEXT, XMP { 
  display: block;
  white-space: pre;
  margin: 1em 0;
  font-family: courier;
}

/* Display properties for hyperlinks */
:link { color: darkblue; text-decoration: underline }

/* Deal with the "nowrap" HTML attribute on table cells. */
TD[nowrap] ,     TH[nowrap]     { white-space: nowrap; }
TD[nowrap="0"] , TH[nowrap="0"] { white-space: normal; }

BR[clear="all"]   { clear: both }
BR[clear="left"]  { clear: left }
BR[clear="right"] { clear: right }
BR { 
    display: block;
    height: 1em;
}
/* BR:before       { content: "\A" } */




/*
 * The following is non-standard CSS syntax to do some mapping between HTML
 * attributes and CSS properties. The syntax used here is really an internal
 * interface, subject to change without notice. There are three special values
 * that may be assigned to properties:
 *
 *     attr(X)
 *         Sets the property to the value of html attribute X for the node
 *         matched by the selector.
 *
 *     ancestor_attr(X, Y)
 *         X is a tag type (i.e. table) and Y is an html attribute name (i.e.
 *         border). This syntax sets the property to the value of attribute Y
 *         if the selected node is of type X, or to the value of attribute Y
 *         from the nearest ancestor of type X.
 *
 *     ancestor_attr_exists(X, Y, Z) 
 *         Arguments X and Y are treated in the same way as for the
 *         ancestor_attr() syntax above. Z is parsed as a regular CSS property
 *         value. If the attribute identified by X and Y exists, then the
 *         property is set to Z.
 *
 * For all of the above, if the requested attribute does not exist, then this
 * is treated as if the declaration was a syntax error (i.e. as if the
 * declaration was not present - some lower priority is used to determine the
 * property value instead).
 */

/* 'color' */
[color]              { color: attr(color) }
body a[href]:link    { color: ancestor_attr(body, link) }
body a[href]:visited { color: ancestor_attr(body, vlink) }

/* 'width', 'height', 'background-color' and 'font-size' */
[width]                    { width: attr(width) }
[height]                   { height: attr(height) }
[bgcolor]                  { background-color: attr(bgcolor) }
font[size], basefont[size] { font-size: attr(size) }

/*
 * Properties of table cells (th, td):
 *
 *     'border-width'
 *     'border-style'
 *     'padding'
 *     'border-spacing'
 */
table[border], table[border] td, table[border] th {
    border-top-width:    ancestor_attr(table, border);
    border-right-width:  ancestor_attr(table, border);
    border-bottom-width: ancestor_attr(table, border);
    border-left-width:   ancestor_attr(table, border);
    border-top-style:    ancestor_attr_exists(table, border, solid);
    border-right-style:  ancestor_attr_exists(table, border, solid);
    border-bottom-style: ancestor_attr_exists(table, border, solid);
    border-left-style:   ancestor_attr_exists(table, border, solid);
}
table[border=""], table[border=""] td, table[border=""] th {
    border-top-width:    ancestor_attr_exists(table, border, 1px);
    border-right-width:  ancestor_attr_exists(table, border, 1px);
    border-bottom-width: ancestor_attr_exists(table, border, 1px);
    border-left-width:   ancestor_attr_exists(table, border, 1px);
    border-top-style:    ancestor_attr_exists(table, border, solid);
    border-right-style:  ancestor_attr_exists(table, border, solid);
    border-bottom-style: ancestor_attr_exists(table, border, solid);
    border-left-style:   ancestor_attr_exists(table, border, solid);
}
table[cellpadding] td, table[cellpadding] th {
    padding-top:    ancestor_attr(table, cellpadding);
    padding-right:  ancestor_attr(table, cellpadding);
    padding-bottom: ancestor_attr(table, cellpadding);
    padding-left:   ancestor_attr(table, cellpadding);
}
table[cellspacing] td, table[cellspacing] th {
    border-spacing: ancestor_attr(table, cellspacing);
}


